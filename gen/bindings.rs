/* automatically generated by rust-bindgen 0.68.1 */

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const ARROW_FLAG_DICTIONARY_ORDERED: u32 = 1;
pub const ARROW_FLAG_NULLABLE: u32 = 2;
pub const ARROW_FLAG_MAP_KEYS_SORTED: u32 = 4;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_XROS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_14_0: u32 = 140000;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_17_0: u32 = 170000;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_17_0: u32 = 170000;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __XROS_1_0: u32 = 10000;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140000;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const QDB_PLATFORM_32: u32 = 0;
pub const QDB_PLATFORM_64: u32 = 1;
pub const QDB_STRING_OFFSETOF_DATA: u32 = 0;
pub const QDB_STRING_OFFSETOF_LENGTH: u32 = 8;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const QDB_BLOB_OFFSETOF_CONTENT: u32 = 0;
pub const QDB_BLOB_OFFSETOF_CONTENT_LENGTH: u32 = 8;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowSchema {
    pub format: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub metadata: *const ::std::os::raw::c_char,
    pub flags: i64,
    pub n_children: i64,
    pub children: *mut *mut ArrowSchema,
    pub dictionary: *mut ArrowSchema,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowSchema)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowSchema() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowSchema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowSchema>(),
        72usize,
        concat!("Size of: ", stringify!(ArrowSchema))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowSchema>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowSchema))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(n_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(private_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArray {
    pub length: i64,
    pub null_count: i64,
    pub offset: i64,
    pub n_buffers: i64,
    pub n_children: i64,
    pub buffers: *mut *const ::std::os::raw::c_void,
    pub children: *mut *mut ArrowArray,
    pub dictionary: *mut ArrowArray,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowArray)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowArray() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowArray>(),
        80usize,
        concat!("Size of: ", stringify!(ArrowArray))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowArray>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).null_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(null_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_buffers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(n_buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(n_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(private_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArrayStream {
    pub get_schema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
            out: *mut ArrowSchema,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
            out: *mut ArrowArray,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_last_error: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ArrowArrayStream) -> *const ::std::os::raw::c_char,
    >,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowArrayStream)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowArrayStream() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowArrayStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowArrayStream>(),
        40usize,
        concat!("Size of: ", stringify!(ArrowArrayStream))
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowArrayStream>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowArrayStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_schema) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_schema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_last_error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_last_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(private_data)
        )
    );
}
pub const qdb_error_origin_t_qdb_e_origin_system_remote: qdb_error_origin_t = -268435456;
pub const qdb_error_origin_t_qdb_e_origin_system_local: qdb_error_origin_t = -536870912;
pub const qdb_error_origin_t_qdb_e_origin_connection: qdb_error_origin_t = -805306368;
pub const qdb_error_origin_t_qdb_e_origin_input: qdb_error_origin_t = -1073741824;
pub const qdb_error_origin_t_qdb_e_origin_operation: qdb_error_origin_t = -1342177280;
pub const qdb_error_origin_t_qdb_e_origin_protocol: qdb_error_origin_t = -1610612736;
#[doc = "! \\ingroup error\n! \\brief The error origin."]
pub type qdb_error_origin_t = ::std::os::raw::c_int;
pub const qdb_error_severity_t_qdb_e_severity_unrecoverable: qdb_error_severity_t = 50331648;
pub const qdb_error_severity_t_qdb_e_severity_error: qdb_error_severity_t = 33554432;
pub const qdb_error_severity_t_qdb_e_severity_warning: qdb_error_severity_t = 16777216;
pub const qdb_error_severity_t_qdb_e_severity_info: qdb_error_severity_t = 0;
#[doc = "! \\ingroup error\n! \\brief An error severity level."]
pub type qdb_error_severity_t = ::std::os::raw::c_uint;
#[doc = "! Success."]
pub const qdb_error_t_qdb_e_ok: qdb_error_t = 0;
#[doc = "! Uninitialized error."]
pub const qdb_error_t_qdb_e_uninitialized: qdb_error_t = -1023344641;
#[doc = "! Entry alias/key was not found."]
pub const qdb_error_t_qdb_e_alias_not_found: qdb_error_t = -1325400056;
#[doc = "! Entry alias/key already exists."]
pub const qdb_error_t_qdb_e_alias_already_exists: qdb_error_t = -1325400055;
#[doc = "! Index out of bounds."]
pub const qdb_error_t_qdb_e_out_of_bounds: qdb_error_t = -1056964583;
#[doc = "! Skipped operation. Used in batches and transactions."]
pub const qdb_error_t_qdb_e_skipped: qdb_error_t = -1325400031;
#[doc = "! Entry or column is incompatible with the operation."]
pub const qdb_error_t_qdb_e_incompatible_type: qdb_error_t = -1325400030;
#[doc = "! Container is empty."]
pub const qdb_error_t_qdb_e_container_empty: qdb_error_t = -1325400029;
#[doc = "! Container is full."]
pub const qdb_error_t_qdb_e_container_full: qdb_error_t = -1325400028;
#[doc = "! Element was not found."]
pub const qdb_error_t_qdb_e_element_not_found: qdb_error_t = -1342177243;
#[doc = "! Element already exists."]
pub const qdb_error_t_qdb_e_element_already_exists: qdb_error_t = -1342177242;
#[doc = "! Arithmetic operation overflows."]
pub const qdb_error_t_qdb_e_overflow: qdb_error_t = -1325400025;
#[doc = "! Arithmetic operation underflows."]
pub const qdb_error_t_qdb_e_underflow: qdb_error_t = -1325400024;
#[doc = "! Tag is already set."]
pub const qdb_error_t_qdb_e_tag_already_set: qdb_error_t = -1342177239;
#[doc = "! Tag is not set."]
pub const qdb_error_t_qdb_e_tag_not_set: qdb_error_t = -1342177238;
#[doc = "! Operation timed out."]
pub const qdb_error_t_qdb_e_timeout: qdb_error_t = -771751926;
#[doc = "! Connection was refused."]
pub const qdb_error_t_qdb_e_connection_refused: qdb_error_t = -754974706;
#[doc = "! Connection was reset."]
pub const qdb_error_t_qdb_e_connection_reset: qdb_error_t = -771751921;
#[doc = "! Cluster is unstable."]
pub const qdb_error_t_qdb_e_unstable_cluster: qdb_error_t = -771751918;
#[doc = "! Please retry."]
pub const qdb_error_t_qdb_e_try_again: qdb_error_t = -771751913;
#[doc = "! There is another ongoing conflicting operation."]
pub const qdb_error_t_qdb_e_conflict: qdb_error_t = -1308622822;
#[doc = "! Handle is not connected."]
pub const qdb_error_t_qdb_e_not_connected: qdb_error_t = -771751909;
#[doc = "! Resource is locked."]
pub const qdb_error_t_qdb_e_resource_locked: qdb_error_t = -1308622803;
#[doc = "! System error on remote node (server-side).\n! Please check `errno` or `GetLastError()` for actual error."]
pub const qdb_error_t_qdb_e_system_remote: qdb_error_t = -218103807;
#[doc = "! System error on local system (client-side).\n! Please check `errno` or `GetLastError()` for actual error."]
pub const qdb_error_t_qdb_e_system_local: qdb_error_t = -486539263;
#[doc = "! Internal error on remote node (server-side)."]
pub const qdb_error_t_qdb_e_internal_remote: qdb_error_t = -218103806;
#[doc = "! Internal error on local system (client-side)."]
pub const qdb_error_t_qdb_e_internal_local: qdb_error_t = -486539262;
#[doc = "! No memory on remote node (server-side)."]
pub const qdb_error_t_qdb_e_no_memory_remote: qdb_error_t = -218103805;
#[doc = "! No memory on local system (client-side)."]
pub const qdb_error_t_qdb_e_no_memory_local: qdb_error_t = -486539261;
#[doc = "! Protocol is invalid."]
pub const qdb_error_t_qdb_e_invalid_protocol: qdb_error_t = -1560281084;
#[doc = "! Host was not found."]
pub const qdb_error_t_qdb_e_host_not_found: qdb_error_t = -771751931;
#[doc = "! Buffer is too small."]
pub const qdb_error_t_qdb_e_buffer_too_small: qdb_error_t = -1056964597;
#[doc = "! Operation is not implemented."]
pub const qdb_error_t_qdb_e_not_implemented: qdb_error_t = -218103791;
#[doc = "! Version is invalid."]
pub const qdb_error_t_qdb_e_invalid_version: qdb_error_t = -1560281066;
#[doc = "! Argument is invalid."]
pub const qdb_error_t_qdb_e_invalid_argument: qdb_error_t = -1040187368;
#[doc = "! Handle is invalid."]
pub const qdb_error_t_qdb_e_invalid_handle: qdb_error_t = -1040187364;
#[doc = "! Alias/key is reserved."]
pub const qdb_error_t_qdb_e_reserved_alias: qdb_error_t = -1040187363;
#[doc = "! Content did not match."]
pub const qdb_error_t_qdb_e_unmatched_content: qdb_error_t = -1342177250;
#[doc = "! Iterator is invalid."]
pub const qdb_error_t_qdb_e_invalid_iterator: qdb_error_t = -1040187361;
#[doc = "! Entry is too large."]
pub const qdb_error_t_qdb_e_entry_too_large: qdb_error_t = -1040187349;
#[doc = "! Transaction failed partially.\n! \\warning This may provoke failures until the transaction has not been rolled back.\n! \\see Cluster configuration parameter `global/cluster/max_transaction_duration`."]
pub const qdb_error_t_qdb_e_transaction_partial_failure: qdb_error_t = -1308622804;
#[doc = "! Operation has not been enabled in cluster configuration."]
pub const qdb_error_t_qdb_e_operation_disabled: qdb_error_t = -1308622802;
#[doc = "! Operation is not permitted."]
pub const qdb_error_t_qdb_e_operation_not_permitted: qdb_error_t = -1308622801;
#[doc = "! Iterator reached the end."]
pub const qdb_error_t_qdb_e_iterator_end: qdb_error_t = -1342177232;
#[doc = "! Cluster sent an invalid reply."]
pub const qdb_error_t_qdb_e_invalid_reply: qdb_error_t = -1560281039;
#[doc = "! Success. A new entry has been created."]
pub const qdb_error_t_qdb_e_ok_created: qdb_error_t = -1342177230;
#[doc = "! No more space on disk."]
pub const qdb_error_t_qdb_e_no_space_left: qdb_error_t = -218103757;
#[doc = "! Disk space quota has been reached."]
pub const qdb_error_t_qdb_e_quota_exceeded: qdb_error_t = -218103756;
#[doc = "! Alias is too long.\n! \\see \\ref qdb_l_max_alias_length"]
pub const qdb_error_t_qdb_e_alias_too_long: qdb_error_t = -1040187339;
#[doc = "! Cluster nodes have important clock differences."]
pub const qdb_error_t_qdb_e_clock_skew: qdb_error_t = -234880970;
#[doc = "! Access is denied."]
pub const qdb_error_t_qdb_e_access_denied: qdb_error_t = -1308622793;
#[doc = "! Login failed."]
pub const qdb_error_t_qdb_e_login_failed: qdb_error_t = -234880968;
#[doc = "! Column was not found."]
pub const qdb_error_t_qdb_e_column_not_found: qdb_error_t = -1325400007;
#[doc = "! Query is too complex."]
pub const qdb_error_t_qdb_e_query_too_complex: qdb_error_t = -1308622784;
#[doc = "! Security key is invalid."]
pub const qdb_error_t_qdb_e_invalid_crypto_key: qdb_error_t = -1040187327;
#[doc = "! Malformed query"]
pub const qdb_error_t_qdb_e_invalid_query: qdb_error_t = -1040187326;
#[doc = "! Malformed regex"]
pub const qdb_error_t_qdb_e_invalid_regex: qdb_error_t = -1040187325;
#[doc = "! Unknown user"]
pub const qdb_error_t_qdb_e_unknown_user: qdb_error_t = -1040187324;
#[doc = "! Task has been interrupted"]
pub const qdb_error_t_qdb_e_interrupted: qdb_error_t = -234880955;
#[doc = "! Client network buffer is too small"]
pub const qdb_error_t_qdb_e_network_inbuf_too_small: qdb_error_t = -503316410;
#[doc = "! Generic network error"]
pub const qdb_error_t_qdb_e_network_error: qdb_error_t = -771751865;
#[doc = "! Corrupted data"]
pub const qdb_error_t_qdb_e_data_corruption: qdb_error_t = -218103736;
#[doc = "! \\ingroup error\n! \\brief An error code indicating success or failure."]
pub type qdb_error_t = ::std::os::raw::c_int;
#[doc = "! \\ingroup error\n! \\brief An alias for \\ref qdb_error_t"]
pub use self::qdb_error_t as qdb_status_t;
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Translates an error code into an English error message\n!\n! \\param error The \\ref qdb_error_t code outputted by another function\n!\n! \\return A static, null-terminated string describing the error.\n! The buffer is API managed and should not be freed or written to by the\n! caller."]
    pub fn qdb_error(error: qdb_error_t) -> *const ::std::os::raw::c_char;
}
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type qdb_time_t = time_t;
#[doc = "! \\ingroup client\n! \\typedef qdb_size_t\n! \\brief An alias for size_t"]
pub type qdb_size_t = usize;
pub type qdb_int16_t = i16;
pub type qdb_uint16_t = u16;
pub type qdb_int_t = i64;
pub type qdb_uint_t = u64;
#[doc = "! The maximum allowed length for aliases."]
pub const qdb_limits_t_qdb_l_max_alias_length: qdb_limits_t = 1024;
#[doc = "! \\deprecated Please use \\ref qdb_l_max_alias_length."]
pub const qdb_limits_t_qdb_l_alias_max_length: qdb_limits_t = 1024;
#[doc = "! The maximum allowed length of a user name."]
pub const qdb_limits_t_qdb_l_max_user_name_length: qdb_limits_t = 120;
#[doc = "! \\deprecated Please use \\ref qdb_l_max_user_name_length."]
pub const qdb_limits_t_qdb_max_user_name_length: qdb_limits_t = 120;
#[doc = "! \\ingroup client\n! \\brief An enumeration of API limits"]
pub type qdb_limits_t = ::std::os::raw::c_uint;
#[doc = "! Uses TCP/IP to communicate with the cluster.\n! This is currently the only supported network protocol."]
pub const qdb_protocol_t_qdb_p_tcp: qdb_protocol_t = 0;
#[doc = "! \\ingroup client\n! \\typedef qdb_protocol_t\n! \\brief An enumeration of allowed network protocols.\n! \\see \\ref qdb_open"]
pub type qdb_protocol_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_handle_internal {
    _unused: [u8; 0],
}
#[doc = "! \\ingroup client\n! \\typedef qdb_handle_t\n! \\brief An opaque handle to internal API-allocated structures needed for\n! maintaining connection to a cluster."]
pub type qdb_handle_t = *mut qdb_handle_internal;
#[doc = "! \\ingroup client\n! \\struct qdb_timespec_t\n! \\brief A structure representing an elapsed time since epoch\n! (cross-platform equivalent of timespec structure)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_timespec_t {
    #[doc = "! number of whole seconds of elapsed time"]
    pub tv_sec: qdb_time_t,
    #[doc = "! rest of the elapsed time, represented as a number of nanoseconds,\n! always less than one billion"]
    pub tv_nsec: qdb_time_t,
}
#[test]
fn bindgen_test_layout_qdb_timespec_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_timespec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_timespec_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_timespec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_timespec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_timespec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_timespec_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_timespec_t),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[doc = "! \\ingroup client\n! \\struct qdb_remote_node_t\n! \\brief A structure representing the address of a quasardb node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_remote_node_t {
    #[doc = "! A pointer to a null-terminated string representing the\n! address of the remote node"]
    pub address: *const ::std::os::raw::c_char,
    #[doc = "! The port of the remote node"]
    pub port: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_qdb_remote_node_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_remote_node_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_remote_node_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_remote_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_remote_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_remote_node_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_remote_node_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_remote_node_t),
            "::",
            stringify!(port)
        )
    );
}
#[doc = "! Uninitialized value."]
pub const qdb_entry_type_t_qdb_entry_uninitialized: qdb_entry_type_t = -1;
#[doc = "! Binary large object (blob)."]
pub const qdb_entry_type_t_qdb_entry_blob: qdb_entry_type_t = 0;
#[doc = "! Signed 64-bit integer."]
pub const qdb_entry_type_t_qdb_entry_integer: qdb_entry_type_t = 1;
#[doc = "! Distributed hash set."]
pub const qdb_entry_type_t_qdb_entry_hset: qdb_entry_type_t = 2;
#[doc = "! Tag."]
pub const qdb_entry_type_t_qdb_entry_tag: qdb_entry_type_t = 3;
#[doc = "! Distributed double-entry queue (deque)."]
pub const qdb_entry_type_t_qdb_entry_deque: qdb_entry_type_t = 4;
#[doc = "! Distributed binary stream."]
pub const qdb_entry_type_t_qdb_entry_stream: qdb_entry_type_t = 5;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_ts: qdb_entry_type_t = 6;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_double_bucket: qdb_entry_type_t = 20;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_blob_bucket: qdb_entry_type_t = 21;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_int64_bucket: qdb_entry_type_t = 22;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_timestamp_bucket: qdb_entry_type_t = 23;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_string_bucket: qdb_entry_type_t = 24;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_double_bucket_index: qdb_entry_type_t = 30;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_blob_bucket_index: qdb_entry_type_t = 31;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_int64_bucket_index: qdb_entry_type_t = 32;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_timestamp_bucket_index: qdb_entry_type_t = 33;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_ts_string_bucket_index: qdb_entry_type_t = 34;
#[doc = "! Distributed time series."]
pub const qdb_entry_type_t_qdb_entry_internal_directory: qdb_entry_type_t = 50;
#[doc = "! \\ingroup client\n! \\typedef qdb_entry_type_t\n! \\brief A enumeration representing possible entries type."]
pub type qdb_entry_type_t = ::std::os::raw::c_int;
#[doc = "! \\ingroup client\n! \\struct qdb_id_t\n! \\brief A cluster-wide unique identifier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_id_t {
    pub data: [qdb_int_t; 4usize],
}
#[test]
fn bindgen_test_layout_qdb_id_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_id_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_id_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_id_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_id_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_id_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "! \\ingroup client\n! \\brief A structure representing a character string of the given length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_string_t {
    pub data: *const ::std::os::raw::c_char,
    pub length: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_string_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_string_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_string_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_string_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_string_t),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "! \\ingroup client\n! \\struct qdb_entry_metadata_t\n! \\brief A structure representing the metadata of an entry in the\n! database."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_entry_metadata_t {
    #[doc = "! Entry key (alias)."]
    pub alias: qdb_string_t,
    #[doc = "! unique identifier"]
    pub reference: qdb_id_t,
    #[doc = "! The type of the entry"]
    pub type_: qdb_entry_type_t,
    #[doc = "! content size for blobs and integers, N/A for other types"]
    pub size: qdb_uint_t,
    #[doc = "! last time the entry was modified\n! May not reflect the actual modification time for distributed\n! containers such as deque and hset."]
    pub modification_time: qdb_timespec_t,
    #[doc = "! The expiry time of the entry, if any."]
    pub expiry_time: qdb_timespec_t,
}
#[test]
fn bindgen_test_layout_qdb_entry_metadata_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_entry_metadata_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_entry_metadata_t>(),
        96usize,
        concat!("Size of: ", stringify!(qdb_entry_metadata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_entry_metadata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_entry_metadata_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_entry_metadata_t),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reference) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_entry_metadata_t),
            "::",
            stringify!(reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_entry_metadata_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_entry_metadata_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modification_time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_entry_metadata_t),
            "::",
            stringify!(modification_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_time) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_entry_metadata_t),
            "::",
            stringify!(expiry_time)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Returns a null-terminated string describing the API version\n!\n! \\return A static, null-terminated string describing the API version.\n! The buffer is API managed and should not be freed or written to by the\n! caller."]
    pub fn qdb_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Returns a null-terminated string describing the exact API build\n!\n! \\return A static, null-terminated string describing the exact API build.\n! The buffer is API managed and should not be freed or written to by the\n! caller."]
    pub fn qdb_build() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Creates a \\ref qdb_handle_t. No connection will be established.\n!\n! \\param[out] handle A pointer to a \\ref qdb_handle_t that will be ready\n! to connect to a cluster.\n!\n! \\param proto The protocol to use.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_connect, \\ref qdb_open_tcp, \\ref qdb_protocol_t"]
    pub fn qdb_open(handle: *mut qdb_handle_t, proto: qdb_protocol_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Creates a TCP/IP qdb_handle_t. No connection will be established.\n!\n! \\return An initialized qdb_handle_t, ready to connect, in case of\n! success, NULL in case of failure.\n!\n! \\see \\ref qdb_connect, \\ref qdb_open"]
    pub fn qdb_open_tcp() -> qdb_handle_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Describes the last error code returned from the given handle.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param[out] error An optional pointer to a \\ref qdb_error_t that will be\n! set to the error code of the last API call with the given handle.\n!\n! \\param[out] message An optional pointer to a \\ref qdb_string_t that will\n! store a message describing the last API call with the given handle. The\n! buffer is API managed and should not be freed or written to by the\n! caller. It's invalidated by subsequent API calls.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!"]
    pub fn qdb_get_last_error(
        handle: qdb_handle_t,
        error: *mut qdb_error_t,
        message: *mut qdb_string_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Binds the client instance to a quasardb cluster and connect to at\n! least one node within.\n!\n! Quasardb URI are in the form `qdb://<address>:<port>` where `<address>`\n! is either an IPv4 or IPv6 (surrounded with square brackets), or a domain\n! name. It is recommended to specify multiple addresses should the\n! designated node be unavailable.\n!\n! URI examples:\n!   - `qdb://myserver.org:2836` - Connects to myserver.org on the port\n!   2836\n!   - `qdb://127.0.0.1:2836` - Connects to the local IPv4 loopback on the\n!   port 2836\n!   - `qdb://myserver1.org:2836,myserver2.org:2836` - Connects to\n!   myserver1.org\n!   or myserver2.org on the port 2836\n!   - `qdb://[::1]:2836` - Connects to the local IPv6 loopback on the port\n!   2836\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A pointer to a null-terminated UTF-8 string representing the\n! URI of the quasardb cluster to connect to.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_open, \\ref qdb_open_tcp\n! \\attention Make sure all the addresses in the URI belong to the same\n! cluster"]
    pub fn qdb_connect(handle: qdb_handle_t, uri: *const ::std::os::raw::c_char) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Closes the handle previously opened with \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! This results in terminating all connections and releasing all internal\n! buffers, including buffers which may\n! have been allocated as or a result of batch operations or get\n! operations.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\attention API-allocated buffers may be released by this call. For\n! example, the buffer allocated by \\ref qdb_blob_get may be released by\n! this call."]
    pub fn qdb_close(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Creates a clone of a buffer using API's high-performance memory\n! allocator.\n!\n! The allocated buffer has to be released later with \\ref qdb_release.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param source_buffer A pointer to a buffer to clone\n!\n! \\param source_buffer_size The size of the buffer to clone\n!\n! \\param[out] dest_buffer A pointer to a a pointer of an API-allocated\n! buffer whose content will be a copy of the source buffer\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_copy_alloc_buffer(
        handle: qdb_handle_t,
        source_buffer: *const ::std::os::raw::c_void,
        source_buffer_size: qdb_size_t,
        dest_buffer: *mut *const ::std::os::raw::c_void,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Releases an API-allocated buffer.\n!\n! Failure to properly call this function may result in excessive memory\n! usage. Most operations that return a content (e.g. batch operations,\n! \\ref qdb_blob_get, \\ref qdb_blob_get_and_update, \\ref\n! qdb_blob_compare_and_swap...) will allocate a buffer for the content and\n! will not release the allocated buffer until you either call this\n! function or close the handle.\n!\n! The function will be able to release any kind of buffer allocated by a\n! quasardb API call, whether it's a single buffer, an array or an array of\n! buffers.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param buffer A pointer to an API-allocated buffer to release. The\n! behavior for non API buffers is undefined."]
    pub fn qdb_release(handle: qdb_handle_t, buffer: *const ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Removes an entry from the cluster, regardless of its type.\n!\n! This call will remove the entry, whether it is a blob, integer, deque,\n! or hset. It will properly untag the entry.\n! If the entry spawns on multiple entries or nodes (deques and hsets),\n! all blocks will be properly removed.\n!\n! The call is ACID, regardless of the type of the entry and a transaction\n! will be created if need be.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_remove(handle: qdb_handle_t, alias: *const ::std::os::raw::c_char) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Sets the absolute expiration time of an entry, if the type\n! supports expiration.\n!\n! Blobs and integers can have an expiration time and will be automatically\n! removed by the cluster when they expire.\n!\n! The absolute expiration time is the Unix epoch, that is, the number of\n! milliseconds since 1 January 1970, 00:00:00 UTC.\n! To use a relative expiration time (that is expiration relative to the\n! time of the call), use \\ref qdb_expires_from_now.\n!\n! To remove the expiration time of an entry, specify the value\n! \\ref qdb_never_expires as \\p expiry_time parameter.\n!\n! Values in the past are refused, but the cluster will have a certain\n! tolerance to account for clock skews.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param expiry_time The new, absolute UTC expiration time.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\attention It is an error to specify an expiration in the past, although\n! the cluster has a certain tolerance to account for clock synchronization\n! \\see \\ref qdb_expires_from_now"]
    pub fn qdb_expires_at(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Sets the expiration time of an entry, relative to the current\n! time of the client, if the type supports expiration.\n!\n! Blobs and integers can have an expiration time and will automatically be\n! removed by the cluster when they expire.\n!\n! The expiration is relative to the current time of the machine.\n!\n! To remove the expiration time of an entry or to use an absolute\n! expiration time use \\ref qdb_expires_at.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param expiry_delta The number of milliseconds, relative to the current\n! time, after which the entry should expire.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_expires_at"]
    pub fn qdb_expires_from_now(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        expiry_delta: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Retrieves the absolute expiration time of the given entry.\n!\n! The returned expiration time is the Unix epoch, UTC.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param[out] expiry_time A pointer to an expiry time which will be set to\n! the expiration of the entry if the call is successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_expires_from_now\n! \\see \\ref qdb_expires_at\n! \\see \\ref qdb_get_metadata"]
    pub fn qdb_get_expiry_time(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        expiry_time: *mut qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Returns the primary node of an entry.\n!\n! The exact location of an entry should be assumed random and users should\n! not bother about its location as the API will transparently locate the\n! best node for the requested operation.\n!\n! This function is intended for higher level APIs that need to optimize\n! transfers and potentially push computation close to the data.\n!\n! This function allocates memory for the null terminated address string\n! call qdb_release on the location structure to release memory.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param[out] location A pointer to a \\ref qdb_remote_node_t structure\n! that will receive the address of the primary node of the entry if\n! successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_get_location(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        location: *mut qdb_remote_node_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Gets the type of an entry, if it exists.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param[out] entry_type A pointer to a \\ref qdb_entry_type_t that will\n! receive the type of the entry if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_metadata"]
    pub fn qdb_get_type(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        entry_type: *mut qdb_entry_type_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Gets the meta-information about an entry, if it exists.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string\n! representing the alias of the entry.\n!\n! \\param[out] entry_metadata A pointer to a \\ref qdb_entry_metadata_t that\n! will receive the metadata of the entry if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_get_metadata(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        entry_metadata: *mut qdb_entry_metadata_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Gets the meta-information about an entry, if it exists.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param reference A pointer to a structure representing the internal\n! reference of the entry.\n!\n! \\param[out] entry_metadata A pointer to a \\ref qdb_entry_metadata_t that\n! will receive the metadata of the entry if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_get_metadata_by_id(
        handle: qdb_handle_t,
        reference: *const qdb_id_t,
        entry_metadata: *mut qdb_entry_metadata_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Removes irremediably all data from all the nodes of the cluster.\n!\n! This function is useful when quasardb is used as a cache and is not the\n! golden source.\n!\n! This call is not atomic: if the command cannot be dispatched on the\n! whole cluster, it will be dispatched on as many nodes as possible and\n! the function will return with a \\ref qdb_e_ok code.\n!\n! By default cluster does not allow this operation and the function\n! returns a \\ref qdb_e_operation_disabled error.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param timeout_ms A timeout value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\attention Use this function at your own risk. This function causes\n! irremediable data loss."]
    pub fn qdb_purge_all(handle: qdb_handle_t, timeout_ms: ::std::os::raw::c_int) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Trims all data on all the nodes of the cluster.\n!\n! quasardb uses Multi-Version Concurrency Control (MVCC) as a foundation\n! of its transaction engine. It will automatically clean up old versions\n! as entries are accessed.\n!\n! This call is not atomic: if the command cannot be dispatched on the\n! whole cluster, it will be dispatched on as many nodes as possible and\n! the function will return with a \\ref qdb_e_ok code.\n!\n! Entries that are not accessed may not be cleaned up, resulting in\n! increasing disk usage.\n!\n! This function will request each node to trim all entries and release\n! unused memory. Because this operation is I/O and CPU intensive, it is\n! not recommended to run it when the cluster is heavily used.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param timeout_ms A timeout value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\attention This function impacts the performance of the cluster.\n!\n! \\see \\ref qdb_cluster_compact"]
    pub fn qdb_trim_all(handle: qdb_handle_t, timeout_ms: ::std::os::raw::c_int) -> qdb_error_t;
}
#[doc = "! Compact the entire database in a single operation"]
pub const qdb_compact_options_t_qdb_compact_full: qdb_compact_options_t = 0;
#[doc = "! Compact the database one slice at a time (reduces peak disk usage\n! during compaction)"]
pub const qdb_compact_options_t_qdb_compact_piecewise: qdb_compact_options_t = 1;
#[doc = "! \\ingroup client\n! \\typedef qdb_compact_options_t\n! \\brief An enumeration of compact options\n! \\see \\ref qdb_cluster_compact"]
pub type qdb_compact_options_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Compacts all data in the persistence layer on all the nodes of\n! the cluster.\n!\n! This function will request each nodes to compact files on disk. Because\n! this operation is I/O and CPU intensive, it is not recommended to run it\n! when the cluster is heavily used.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param options Options for the compaction operation.\n!\n! \\param timeout_ms A timeout value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\attention This function impacts the performance of the cluster.\n!\n! \\see \\ref qdb_trim_all"]
    pub fn qdb_cluster_compact(
        handle: qdb_handle_t,
        options: qdb_compact_options_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Removes all cached data from all the nodes of the cluster.\n!\n! This function is disabled on a transient cluster.\n! Prefer purge_all in this case.\n!\n! This call is not atomic: if the command cannot be dispatched on the\n! whole cluster, it will be dispatched on as many nodes as possible and\n! the function will return with a \\ref qdb_e_ok code.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param timeout_ms A timeout value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_purge_cache(handle: qdb_handle_t, timeout_ms: ::std::os::raw::c_int) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Wait for all nodes of the cluster to be stabilized.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param timeout_ms A timeout value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_wait_for_stabilization(
        handle: qdb_handle_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Retrieve a sorted array of endpoints.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param[out] endpoints A pointer to a \\ref qdb_remote_node_t array\n! that will receive the addresses of the nodes of the cluster\n!\n! \\param[out] endpoints_count A pointer that will be filled with number of\n! nodes in the array\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_cluster_endpoints(
        handle: qdb_handle_t,
        endpoints: *mut *mut qdb_remote_node_t,
        endpoints_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Reload user configuration from file.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_cluster_reload_user_config(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the timeout of all network operations.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param timeout_ms The timeout of network operation, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark The lower the timeout, the higher the risk of having timeout\n! errors."]
    pub fn qdb_option_set_timeout(
        handle: qdb_handle_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the timeout of all network operations.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param[out] timeout_ms A pointer to the variable that will receive the\n! timeout value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_get_timeout(
        handle: qdb_handle_t,
        timeout_ms: *mut ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the maximum incoming buffer size for all network operations\n! of the client.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param max_size The maximum input size in bytes\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark Only modify this setting if you expect to receive very large\n! answers from the server."]
    pub fn qdb_option_set_client_max_in_buf_size(
        handle: qdb_handle_t,
        max_size: usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the maximum incoming buffer size for all network operations\n! of the client.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param max_size A pointer that will receive the current maximum\n! incoming buffer size.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_get_client_max_in_buf_size(
        handle: qdb_handle_t,
        max_size: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the maximum incoming buffer size for all network operations\n! of the remote cluster.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param max_size A pointer that will receive the current maximum\n! incoming buffer size.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_get_cluster_max_in_buf_size(
        handle: qdb_handle_t,
        max_size: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the maximum stabilization waiting time for operations.\n!\n! This value has no impact for operations on a stable cluster. It must\n! higher than the timeout value.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param wait_ms The maximum amount of time to wait, in ms.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark The lower the value, the higher the chance of having\n! \"cluster unstable\" errors"]
    pub fn qdb_option_set_stabilization_max_wait(
        handle: qdb_handle_t,
        wait_ms: ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the maximum stabilization waiting time for operations.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param[out] wait_ms A pointer to the variable that will receive the\n! waiting value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_get_stabilization_max_wait(
        handle: qdb_handle_t,
        wait_ms: *mut ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the maximum transaction retry time for operations.\n!\n! This value has no impact when transaction do not conflict.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param wait_ms The maximum amount of time to wait, in ms.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark The lower the value, the higher the chance of having\n! \"conflicting transactions\" errors."]
    pub fn qdb_option_set_transaction_max_wait(
        handle: qdb_handle_t,
        wait_ms: ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the maximum transaction retry time for operations.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param[out] wait_ms A pointer to the variable that will receive the\n! waiting value, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_get_transaction_max_wait(
        handle: qdb_handle_t,
        wait_ms: *mut ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the maximum allowed cardinality of a quasardb query. The\n! default value is 100'003. The minimum allowed value is 100.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp\n!\n! \\param max_cardinality The maximum cardinality of a query.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark Improper usage of this function may cause a denial of service on\n! the client."]
    pub fn qdb_option_set_max_cardinality(
        handle: qdb_handle_t,
        max_cardinality: qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the number of threads that will be used to execute queries\n! by the current handle.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp\n!\n! \\param thread_count Number of threads. Value of 0 means the number of\n! logical processor cores.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark Improper usage of this function may cause performance issues."]
    pub fn qdb_option_set_client_max_parallelism(
        handle: qdb_handle_t,
        thread_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the number of threads that will be used to execute queries\n! by the current handle.\n!\n! \\param handle The qdb_handle_t that was initialized with \\ref qdb_open\n! or \\ref qdb_open_tcp\n!\n! \\param[out] thread_count A pointer to variable that will receive the\n! number of threads.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n!\n! \\remark Improper usage of this function may cause performance issues."]
    pub fn qdb_option_get_client_max_parallelism(
        handle: qdb_handle_t,
        thread_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the state of the load-balancing.\n!\n! By default the client will not use automatic load-balancing.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param[out] is_enabled A pointer to variable that will receive an\n! integer indicating whether the load-balacing is enabled (positive) or\n! disabled (zero).\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_option_disable_client_load_balancing"]
    pub fn qdb_option_get_client_load_balancing(
        handle: qdb_handle_t,
        is_enabled: *mut ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Enables load-balancing for all threads.\n!\n! By default the client will not use automatic load-balancing.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_option_disable_client_load_balancing"]
    pub fn qdb_option_enable_client_load_balancing(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Disables load-balancing for all threads.\n!\n! By default the client will not use automatic load-balancing.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_option_enable_client_load_balancing"]
    pub fn qdb_option_disable_client_load_balancing(handle: qdb_handle_t) -> qdb_error_t;
}
#[doc = "! No compression"]
pub const qdb_compression_t_qdb_comp_none: qdb_compression_t = 0;
#[doc = "! Maximum compression speed, potentially minimum compression ratio.\n! This is currently the default."]
pub const qdb_compression_t_qdb_comp_fast: qdb_compression_t = 1;
#[doc = "! Maximum compression ratio, potentially minimum compression speed.\n! This is currently not implemented."]
pub const qdb_compression_t_qdb_comp_best: qdb_compression_t = 2;
#[doc = "! \\ingroup option\n! \\brief An enumeration of compression parameters\n! \\see \\ref qdb_option_set_compression"]
pub type qdb_compression_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Set the compression level for all future messages emitted by the\n! specified handle. Regardless of this parameter, the API will\n! be able to read whatever compression the server uses.\n!\n! \\param handle The handle on which to set the compression level\n!\n! \\param comp_level The compression level to use\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_compression_t\n! \\remark For better performance, consider disabling compression if your\n! data is already compressed."]
    pub fn qdb_option_set_compression(
        handle: qdb_handle_t,
        comp_level: qdb_compression_t,
    ) -> qdb_error_t;
}
#[doc = "!< No encryption."]
pub const qdb_encryption_t_qdb_crypt_none: qdb_encryption_t = 0;
#[doc = "!< AEC-GCM 256-bit encryption."]
pub const qdb_encryption_t_qdb_crypt_aes_gcm_256: qdb_encryption_t = 1;
#[doc = "! \\ingroup option\n! \\brief An enumeration of encryption parameters\n! \\see \\ref qdb_option_set_encryption"]
pub type qdb_encryption_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Set the encryption method for all future messages emitted by the\n! specified handle.\n!\n! \\see \\ref qdb_encryption_t\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_set_encryption(
        handle: qdb_handle_t,
        encryption: qdb_encryption_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Set the public key of the cluster used for authentification of\n! nodes on connection.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_set_cluster_public_key(
        handle: qdb_handle_t,
        public_key: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Set the user credentials (name and private key) used for\n! authentification of the user on connection.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_set_user_credentials(
        handle: qdb_handle_t,
        user_name: *const ::std::os::raw::c_char,
        private_key: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Set the user credentials and cluster public key used for\n! authentification of the user on connection.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_option_load_security_files(
        handle: qdb_handle_t,
        cluster_public_key_file: *const ::std::os::raw::c_char,
        user_credentials_file: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Sets the timeout of \\ref qdb_ts_batch_push_async operation.\n!\n! \\param handle The handle on which to set the batch async push timeout\n!\n! \\param timeout_ms The timeout to set, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\remark The lower the timeout, the higher the risk of having\n! timeout errors.\n! \\see qdb_ts_batch_push_async."]
    pub fn qdb_option_set_ts_batch_push_async_timeout(
        handle: qdb_handle_t,
        timeout_ms: ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Gets the timeout of \\ref qdb_ts_batch_push_async operation.\n!\n! \\param handle The handle on which to get the batch async push timeout\n!\n! \\param[out] timeout_ms A pointer to the timeout, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see qdb_ts_batch_push_async."]
    pub fn qdb_option_get_ts_batch_push_async_timeout(
        handle: qdb_handle_t,
        timeout_ms: *mut ::std::os::raw::c_int,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Enables automatic compactions in the cluster's persistence.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see A \\ref qdb_option_cluster_disable_auto_compaction"]
    pub fn qdb_option_cluster_enable_auto_compaction(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup option\n! \\brief Disables automatic compactions in the cluster's persistence.\n! Manual compaction is still possible.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see A \\ref qdb_option_cluster_enable_auto_compaction"]
    pub fn qdb_option_cluster_disable_auto_compaction(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! EXPERIMENTAL. Use at your own risk!"]
    pub fn qdb_option_cluster_tidy_memory(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! EXPERIMENTAL. Use at your own risk!"]
    pub fn qdb_option_cluster_disable_async_pipelines(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! EXPERIMENTAL. Use at your own risk!"]
    pub fn qdb_option_cluster_enable_async_pipelines(handle: qdb_handle_t) -> qdb_error_t;
}
#[doc = "! Unitialized value"]
pub const qdb_operation_type_t_qdb_op_uninitialized: qdb_operation_type_t = -1;
#[doc = "! A blob get operation"]
pub const qdb_operation_type_t_qdb_op_blob_get: qdb_operation_type_t = 0;
#[doc = "! A blob put operation"]
pub const qdb_operation_type_t_qdb_op_blob_put: qdb_operation_type_t = 1;
#[doc = "! A blob update operation"]
pub const qdb_operation_type_t_qdb_op_blob_update: qdb_operation_type_t = 2;
#[doc = "! A blob compare and swap operation"]
pub const qdb_operation_type_t_qdb_op_blob_cas: qdb_operation_type_t = 4;
#[doc = "! A blob get and update"]
pub const qdb_operation_type_t_qdb_op_blob_get_and_update: qdb_operation_type_t = 5;
#[doc = "! Tag existence test operation"]
pub const qdb_operation_type_t_qdb_op_has_tag: qdb_operation_type_t = 8;
#[doc = "! An integer put operation"]
pub const qdb_operation_type_t_qdb_op_int_put: qdb_operation_type_t = 9;
#[doc = "! An integer update operation"]
pub const qdb_operation_type_t_qdb_op_int_update: qdb_operation_type_t = 10;
#[doc = "! An integer get operation"]
pub const qdb_operation_type_t_qdb_op_int_get: qdb_operation_type_t = 11;
#[doc = "! An integer increase/decrease operation"]
pub const qdb_operation_type_t_qdb_op_int_add: qdb_operation_type_t = 12;
#[doc = "! Entry type check"]
pub const qdb_operation_type_t_qdb_op_get_entry_type: qdb_operation_type_t = 13;
#[doc = "! A value get operation"]
pub const qdb_operation_type_t_qdb_op_value_get: qdb_operation_type_t = 14;
#[doc = "! \\ingroup batch\n! \\typedef qdb_operation_type_t\n! \\brief An enumeration of possible operation type.\n!\n! Operations are used by batches and transactions."]
pub type qdb_operation_type_t = ::std::os::raw::c_int;
#[doc = "! \\ingroup batch\n! \\brief The required parameters for an integer operation within a batch"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int_put_update_t {
    #[doc = "! The value of the integer to use."]
    pub value: qdb_int_t,
    #[doc = "! The optional expiration time. Use \\ref qdb_never_expires for no\n! expiration."]
    pub expiry_time: qdb_time_t,
}
#[test]
fn bindgen_test_layout_int_put_update_t() {
    const UNINIT: ::std::mem::MaybeUninit<int_put_update_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<int_put_update_t>(),
        16usize,
        concat!("Size of: ", stringify!(int_put_update_t))
    );
    assert_eq!(
        ::std::mem::align_of::<int_put_update_t>(),
        8usize,
        concat!("Alignment of ", stringify!(int_put_update_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int_put_update_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int_put_update_t),
            "::",
            stringify!(expiry_time)
        )
    );
}
#[doc = "! \\ingroup batch\n! \\brief The required parameters for a blob put or update operations\n! within a batch"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blob_put_update_t {
    #[doc = "! A pointer to the buffer with the data to be written."]
    pub content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the buffer pointed by content."]
    pub content_size: qdb_size_t,
    #[doc = "! The optional expiration time. Use \\ref qdb_never_expires for no\n! expiration."]
    pub expiry_time: qdb_time_t,
}
#[test]
fn bindgen_test_layout_blob_put_update_t() {
    const UNINIT: ::std::mem::MaybeUninit<blob_put_update_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blob_put_update_t>(),
        24usize,
        concat!("Size of: ", stringify!(blob_put_update_t))
    );
    assert_eq!(
        ::std::mem::align_of::<blob_put_update_t>(),
        8usize,
        concat!("Alignment of ", stringify!(blob_put_update_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blob_put_update_t),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blob_put_update_t),
            "::",
            stringify!(content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blob_put_update_t),
            "::",
            stringify!(expiry_time)
        )
    );
}
#[doc = "! \\ingroup batch\n! \\brief A single operation containing all parameters to execute the\n! operation in a batch or in a transaction.\n!\n! You should initialize operations before usage with the \\ref\n! qdb_init_operations function.\n!"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdb_operation_t {
    #[doc = "! The type of the operation"]
    pub type_: qdb_operation_type_t,
    #[doc = "! A pointer to a null-terminated UTF-8 string representing the\n! alias of the entry."]
    pub alias: *const ::std::os::raw::c_char,
    #[doc = "! A \\ref qdb_error_t code indicating success or failure after the\n! operation has been executed"]
    pub error: qdb_error_t,
    pub __bindgen_anon_1: qdb_operation_t__bindgen_ty_1,
}
#[doc = "! Operation specific parameters"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union qdb_operation_t__bindgen_ty_1 {
    pub has_tag: qdb_operation_t__bindgen_ty_1__bindgen_ty_1,
    pub int_add: qdb_operation_t__bindgen_ty_1__bindgen_ty_2,
    pub int_get: qdb_operation_t__bindgen_ty_1__bindgen_ty_3,
    #[doc = "! Integer put specific operation parameters"]
    pub int_put: int_put_update_t,
    #[doc = "! Integer update specific operation parameters"]
    pub int_update: int_put_update_t,
    pub get_entry_type: qdb_operation_t__bindgen_ty_1__bindgen_ty_4,
    #[doc = "! Blob put specific operation parameters"]
    pub blob_put: blob_put_update_t,
    #[doc = "! Blob update specific operation parameters"]
    pub blob_update: blob_put_update_t,
    pub blob_cas: qdb_operation_t__bindgen_ty_1__bindgen_ty_5,
    pub blob_get: qdb_operation_t__bindgen_ty_1__bindgen_ty_6,
    pub blob_get_and_update: qdb_operation_t__bindgen_ty_1__bindgen_ty_7,
    pub value_get: qdb_operation_t__bindgen_ty_1__bindgen_ty_8,
}
#[doc = "! Tag specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "! A pointer to a null-terminated UTF-8 string representing the\n! tag to test for existence"]
    pub tag: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tag)
        )
    );
}
#[doc = "! Integer increment/decrement specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "! A signed 64-bit integer representing the result of the\n! operation"]
    pub result: qdb_int_t,
    #[doc = "! The value to add or subtract to the entry"]
    pub addend: qdb_int_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(addend)
        )
    );
}
#[doc = "! Integer get specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "! The result of the integer get operation"]
    pub result: qdb_int_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(result)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "! The result of the get entry type operation"]
    pub type_: qdb_entry_type_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "! Blob compare and swap specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_5 {
    #[doc = "! A pointer to the buffer containing the result of the blob\n! operation, if any.\n! This buffer is API-allocated and will be freed by a call to\n! \\ref qdb_release"]
    pub original_content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the result buffer."]
    pub original_content_size: qdb_size_t,
    #[doc = "! A pointer to the buffer with the data to be written."]
    pub new_content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the buffer pointed by content."]
    pub new_content_size: qdb_size_t,
    #[doc = "! A pointer to the comparand."]
    pub comparand: *const ::std::os::raw::c_void,
    #[doc = "! The size of the buffer pointed by comparand."]
    pub comparand_size: qdb_size_t,
    #[doc = "! Optional offset for the comparand.\n! Leave to 0 if not needed."]
    pub comparand_offset: qdb_size_t,
    #[doc = "! The optional expiration time. Use \\ref qdb_never_expires for\n! no expiration."]
    pub expiry_time: qdb_time_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_5>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(original_content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_content_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(original_content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_content) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(new_content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_content_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(new_content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comparand) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(comparand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comparand_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(comparand_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comparand_offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(comparand_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(expiry_time)
        )
    );
}
#[doc = "! Blob get specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_6 {
    #[doc = "! A pointer to the buffer containing the result of the blob\n! operation\n! This buffer is API-allocated and will be freed by a call to\n! \\ref qdb_release"]
    pub content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the result buffer."]
    pub content_size: qdb_size_t,
    #[doc = "! Optional offset from which the content should be returned.\n! Leave to 0 if not needed."]
    pub content_offset: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_6>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(content_offset)
        )
    );
}
#[doc = "! Blob get and update specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_7 {
    #[doc = "! A pointer to the buffer containing the result of the blob\n! operation\n! This buffer is API-allocated and will be freed by a call to\n! \\ref qdb_release"]
    pub original_content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the result buffer."]
    pub original_content_size: qdb_size_t,
    #[doc = "! A pointer to the buffer with the data to be written."]
    pub new_content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the buffer pointed by content."]
    pub new_content_size: qdb_size_t,
    #[doc = "! The optional expiration time. Use \\ref qdb_never_expires for\n! no expiration."]
    pub expiry_time: qdb_time_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_7>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(original_content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_content_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(original_content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_content) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(new_content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).new_content_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(new_content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiry_time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(expiry_time)
        )
    );
}
#[doc = "! Value get specific operation parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_operation_t__bindgen_ty_1__bindgen_ty_8 {
    #[doc = "! The type of the entry returned by the get value operation"]
    pub type_: qdb_entry_type_t,
    #[doc = "! A pointer to the buffer containing the result of the get\n! operation when the returned type is blob\n! This buffer is API-allocated and will be freed by a call to\n! \\ref qdb_release"]
    pub blob_content: *const ::std::os::raw::c_void,
    #[doc = "! The size of the result buffer."]
    pub blob_content_size: qdb_size_t,
    #[doc = "! The result of the get operation when the returned type is\n! integer"]
    pub int_result: qdb_int_t,
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1__bindgen_ty_8> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_8>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_content) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(blob_content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_content_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(blob_content_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_result) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(int_result)
        )
    );
}
#[test]
fn bindgen_test_layout_qdb_operation_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(qdb_operation_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_operation_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(has_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_add) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(int_add)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(int_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_put) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(int_put)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(int_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_entry_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(get_entry_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_put) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(blob_put)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(blob_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_cas) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(blob_cas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(blob_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob_get_and_update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(blob_get_and_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t__bindgen_ty_1),
            "::",
            stringify!(value_get)
        )
    );
}
#[test]
fn bindgen_test_layout_qdb_operation_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_operation_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_operation_t>(),
        88usize,
        concat!("Size of: ", stringify!(qdb_operation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_operation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_operation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_operation_t),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup batch\n! \\brief Initializes an array of \\ref qdb_operation_t\n!\n! Use this function to make sure all the fields of the operation structure\n! are properly initialized to their default values.\n!\n! After this function has been called, the user must then set the required\n! parameter for each\n! operation.\n!\n! \\param operations A pointer to an array of operations\n!\n! \\param operation_count The number of elements in the array of operations\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_operation_t"]
    pub fn qdb_init_operations(
        operations: *mut qdb_operation_t,
        operation_count: usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup batch\n! \\brief Runs the operations in batch.\n!\n! When operations are run in batch the order of execution is optimized for\n! speed and each operation is run independently.\n!\n! Running operations is batch is generally the best way to achieve a very\n! high level of performance, especially for bulk loading of data. That's\n! because batches minimize network communication and organize the order of\n! execution for maximum throughput.\n!\n! If one or several operations within the batch fail, the rest of the\n! batch isn't affected.\n!\n! If one or several operations within the batch is ill-formed, the whole\n! batch will be aborted. An ill formed operation is for example an\n! operation missing a parameter.\n!\n! Each operation will result a result according to its type.\n!\n! After a batch has been run (successful or not), the user must call\n! \\ref qdb_release on the operations pointer to release all API-allocated\n! buffers.\n!\n! For an ordered,  transactional \"all or nothing\" behavior use\n! \\ref qdb_run_transaction.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param operations A pointer to a correctly constructed array of\n! operations\n!\n!\n! \\param operation_count The number of elements in the array of operations\n!\n! \\return The number of successful operations in the batch.\n!\n! \\see \\ref qdb_operation_t, \\ref qdb_run_transaction, \\ref qdb_release"]
    pub fn qdb_run_batch(
        handle: qdb_handle_t,
        operations: *mut qdb_operation_t,
        operation_count: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "! \\ingroup batch\n! \\brief Runs the operations in a single transaction.\n!\n! Operations that run in a transaction will be executed ordered to\n! preserve the logic of the transaction and if an error occurred the\n! previously executed operations will be rolled back.\n!\n! The operation is committed if and only if all operations have been\n! successful.\n!\n! The result of the transaction is not visible by other clients until it\n! has been committed.\n!\n! After a transaction has been run (successful or not), the user must call\n! \\ref qdb_release on operations to release all API-allocated buffers.\n!\n! Use transactions when integrity and order is paramount. For maximum\n! performances\n! consider using batches (\\ref qdb_run_batch).\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param operations A pointer to a correctly constructed array of\n! operations\n!\n! \\param operation_count The number of elements in the array of operations\n!\n! \\param failed_index A pointer to the index of the first failed operation\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_operation_t, \\ref qdb_run_batch, \\ref qdb_release"]
    pub fn qdb_run_transaction(
        handle: qdb_handle_t,
        operations: *mut qdb_operation_t,
        operation_count: usize,
        failed_index: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Retrieves an entry's content from the quasardb server. The caller\n!        is responsible for allocating and freeing the provided buffer.\n!\n! If the entry does not exist, the function will fail and return\n! \\ref qdb_e_alias_not_found.\n!\n! If the buffer is not large enough to hold the data, the function will\n! fail and return \\ref qdb_e_buffer_too_small. \\p content_length will\n! nevertheless be updated with entry size so that the caller may resize\n! its buffer and try again.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string\n! representing the alias of the entry.\n!\n! \\param[in,out] content A pointer to a user-allocated buffer that will\n! receive the entry's content.\n!\n! \\param[out] content_length A pointer to a \\ref qdb_size_t initialized\n! with the length of the destination buffer, in bytes. It will be updated\n! with the length of the retrieved content, even if the buffer is not\n! large enough to hold all the data.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_get_noalloc(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *mut ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Retrieves an entry's content from the quasardb server.\n!\n! If the entry does not exist, the function will fail and return\n! \\ref qdb_e_alias_not_found.\n!\n! The function will allocate a buffer large enough to hold the entry's\n! content. This buffer must be released by the caller with a call to\n! \\ref qdb_release().\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string\n! representing the alias of the entry.\n!\n! \\param[out] content A pointer to a pointer that will be set to a\n! function-allocated buffer holding the entry's content.\n!\n! \\param[out] content_length A pointer to a \\ref qdb_size_t that will be\n! set to the content's size, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_get(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Retrieves a part of an entry's content from the quasardb server.\n!\n! If the entry does not exist, the function will fail and return\n! \\ref qdb_e_alias_not_found.\n!\n! The function will allocate a buffer large enough to hold the entry's\n! content. This buffer must be released by the caller with a call to\n! \\ref qdb_release().\n!\n! The returned content will be a subset of the entry's data in the range\n! <tt>[</tt>\\p offset<tt>, </tt>\\p offset<tt> + *</tt>\\p\n! content_length<tt>)</tt>.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param[out] content A pointer to a pointer that will be set to a\n! function-allocated buffer holding the entry's content.\n!\n! \\param[out] content_length A pointer to a \\ref qdb_size_t that holds the\n! length of the requested content and that will be set to the returned\n! content's size, in bytes. If content length is equal to zero or is\n! greater than entry's length minus offset, then all the content from\n! offset until the end will be returned.\n!\n! \\param offset Offset from which to get content, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_reserved_blob_get(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
        offset: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Atomically gets an entry from the quasardb server and removes it.\n!\n! If the entry does not exist, the function will fail and return\n! \\ref qdb_e_alias_not_found.\n!\n! The function will allocate a buffer large enough to hold the entry's\n! content. This buffer must be released by the caller with a call to\n! \\ref qdb_release().\n!\n! If the buffer is not large enough to hold the data, the function will\n! fail and return \\ref qdb_e_buffer_too_small. \\p content_length will\n! nevertheless be updated with entry size so that the caller may resize\n! its buffer and try again.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string\n! representing the alias of the entry.\n!\n! \\param[out] content A pointer to a pointer that will be set to a\n! function-allocated buffer holding the entry's content.\n!\n! \\param[out] content_length A pointer to a \\ref qdb_size_t that will be\n! set to the content's size, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_get_and_remove(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Creates a new entry and sets its content to the provided blob\n!\n! If the entry already exists the function will fail and will return\n! \\ref qdb_e_alias_already_exists.\n!\n! You can specify an expiry or use \\ref qdb_never_expires if you don't\n! want the entry to expire.\n!\n! There is no software-defined limit to the size of blobs.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param content A pointer to the buffer with the blob content\n!\n! \\param content_length The length of the buffer, in bytes\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_put(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Creates or updates an entry and sets its content to the provided\n! blob\n!\n! If the entry already exists, the function will modify the entry.\n!\n! You can specify an expiry or use \\ref qdb_never_expires if you don't\n! want the entry to expire.\n!\n! There is no software-defined limit to the size of blobs.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param content A pointer to the buffer with the blob content\n!\n! \\param content_length The length of the buffer, in bytes\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_update(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief This function is reserved for internal use and its usage is\n! discouraged.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param content A pointer to the content to merge\n!\n! \\param content_length The length of the buffer, in bytes\n!\n! \\param offset Offset at which merge content\n!\n! \\param truncate 1 - the entry will be truncated at the end of the new\n! buffer.\n!                 0 - the original content will be preserved.\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_reserved_blob_merge(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
        offset: qdb_size_t,
        truncate: ::std::os::raw::c_int,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Atomically gets and updates (in this order) the entry on the\n! quasardb server.\n!\n! The entry must already exist.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param update_content A pointer to the buffer with the new blob content\n!\n! \\param update_content_length The length of the buffer, in bytes\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\param[out] get_content A pointer to a pointer to an API-allocated\n! buffer holding the entry content, before the update.\n!\n! \\param[out] get_content_length A pointer to a \\ref qdb_size_t that will\n! be set to the content's size, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_get_and_update(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        update_content: *const ::std::os::raw::c_void,
        update_content_length: qdb_size_t,
        expiry_time: qdb_time_t,
        get_content: *mut *const ::std::os::raw::c_void,
        get_content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Atomically compares the entry with comparand and updates it to\n!        \\p new_value if, and only if, they match.\n!\n! The function returns the original value of the entry in case of a\n! mismatch. When it matches, no content is returned.\n!\n! The entry must already exist.\n!\n! Update will occur if and only if the content of the entry matches bit\n! for bit the content of the comparand buffer.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param new_value A pointer to a buffer that represents the entry's\n! content to be updated to the server in case of match.\n!\n! \\param new_value_length The length of the buffer, in bytes\n!\n! \\param comparand A pointer to a buffer that represents the entry's\n! content to be compared to.\n!\n! \\param comparand_length The length of the buffer, in bytes\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\param[out] original_value A pointer to a pointer that will be set to a\n! function-allocated buffer holding the entry's original content, before\n! the update, if any.\n!\n! \\param[out] original_value_length A pointer to a \\ref qdb_size_t that\n! will be set to the content's size, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_compare_and_swap(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        new_value: *const ::std::os::raw::c_void,
        new_value_length: qdb_size_t,
        comparand: *const ::std::os::raw::c_void,
        comparand_length: qdb_size_t,
        expiry_time: qdb_time_t,
        original_value: *mut *const ::std::os::raw::c_void,
        original_value_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    pub fn qdb_reserved_blob_cas_partial(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        new_value: *const ::std::os::raw::c_void,
        new_value_length: qdb_size_t,
        comparand: *const ::std::os::raw::c_void,
        comparand_length: qdb_size_t,
        comparand_offset: qdb_size_t,
        expiry_time: qdb_time_t,
        original_value: *mut *const ::std::os::raw::c_void,
        original_value_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Atomically removes the entry on the server if the content\n! matches.\n!\n! The entry must already exist.\n!\n! Removal will occur if and only if the content of the entry matches bit\n! for bit the content of the comparand buffer.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open\n! or \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string\n! representing the alias of the entry.\n!\n! \\param comparand A pointer to a buffer to use a comparand\n!\n! \\param comparand_length The length of the buffer, in bytes\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_remove_if(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        comparand: *const ::std::os::raw::c_void,
        comparand_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief Retrieves all blobs that have content matching the specified\n! pattern\n!\n! \\warning This function is experimental.\n!\n! The complexity of this function is linear in the number of entries.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param pattern A pointer to the pattern buffer to search for\n!\n! \\param pattern_length The length of the pattern buffer, in bytes\n!\n! \\param max_count An integer limiting the number of results returned by\n! the function\n!\n! \\param[out] aliases A pointer to an array of null-terminated UTF-8\n! string that will list the aliases of the entries matching the requested\n! pattern.\n!\n! \\param[out] alias_count A pointer to an integer that will receive the\n! number of returned aliases.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_blob_scan(
        handle: qdb_handle_t,
        pattern: *const ::std::os::raw::c_void,
        pattern_length: qdb_size_t,
        max_count: qdb_int_t,
        aliases: *mut *mut *const ::std::os::raw::c_char,
        alias_count: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup blob\n! \\brief   Retrieves all blobs that have content matching the specified\n! regular expression (regex)\n!\n! \\warning This function is experimental.\n!\n! The complexity of this function is linear in the number of entries.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param pattern A pointer to a null-terminated UTF-8 string representing\n! the regular expression to search for. The regex syntax is\n! defined by ECMA-262 grammar.\n!\n! \\param max_count An integer limiting the number of results returned by\n! the function.\n!\n! \\param[out] aliases A pointer to an array of null-terminated UTF-8\n! string that will list the aliases of the entries matching the requested\n! pattern.\n!\n! \\param[out] alias_count A pointer to an integer that will receive the\n! number of returned aliases.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see http://ecma-international.org/ecma-262/5.1/#sec-15.10"]
    pub fn qdb_blob_scan_regex(
        handle: qdb_handle_t,
        pattern: *const ::std::os::raw::c_char,
        max_count: qdb_int_t,
        aliases: *mut *mut *const ::std::os::raw::c_char,
        alias_count: *mut usize,
    ) -> qdb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_direct_handle_internal {
    _unused: [u8; 0],
}
#[doc = "! \\ingroup client\n! \\typedef qdb_direct_handle_t\n! \\brief An opaque handle to internal API-allocated structures needed for\n! maintaining a direct connection to a cluster."]
pub type qdb_direct_handle_t = *mut qdb_direct_handle_internal;
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Opens a direct connection to a node for use with the direct API.\n!\n! The returned handled must be freed with qdb_direct_close. Releasing the\n! direct handle has no impact on non-direct connections or other direct\n! handles.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A string representing the node address and port (without the\n! qdb:// prefix)\n!\n! \\return A valid qdb_direct_handle_t if successful, a null pointer."]
    pub fn qdb_direct_connect(
        handle: qdb_handle_t,
        uri: *const ::std::os::raw::c_char,
    ) -> qdb_direct_handle_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Close a direct handle initially opened with qdb_direct_connect.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect"]
    pub fn qdb_direct_close(handle: qdb_direct_handle_t);
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Retrieves an entry's content from a quasardb node's local\n! storage.\n!\n! If the entry does not exist, the function will fail and return\n! \\ref qdb_e_alias_not_found.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! The function will allocate a buffer large enough to hold the entry's\n! content. This buffer must be released by the caller with a call to\n! \\ref qdb_release().\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string\n! representing the alias of the entry.\n!\n! \\param[out] content A pointer to a pointer that will be set to a\n! function-allocated buffer holding the entry's content.\n!\n! \\param[out] content_length A pointer to a \\ref qdb_size_t that will be\n! set to the content's size, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_direct_blob_get(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Creates a new entry and sets its content to the provided blob\n!\n! If the entry already exists the function will fail and will return\n! \\ref qdb_e_alias_already_exists.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! You can specify an expiry or use \\ref qdb_never_expires if you don't\n! want the entry to expire.\n!\n! There is no software-defined limit to the size of blobs.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param content A pointer to the buffer with the blob content\n!\n! \\param content_length The length of the buffer, in bytes\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_direct_blob_put(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Creates or updates an entry and sets its content to the provided\n! blob\n!\n! If the entry already exists, the function will modify the entry.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! You can specify an expiry or use \\ref qdb_never_expires if you don't\n! want the entry to expire.\n!\n! There is no software-defined limit to the size of blobs.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param content A pointer to the buffer with the blob content\n!\n! \\param content_length The length of the buffer, in bytes\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_direct_blob_update(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Removes an entry from the local node's storage, regardless of its\n! type.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! The call is ACID, regardless of the type of the entry and a transaction\n! will be created if need be.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_direct_remove(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Creates a new signed 64-bit integer.\n!\n! Atomically creates an entry of the given alias and sets it to a\n! cross-platform signed 64-bit integer.\n! If the entry already exists, the function returns an error.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! You can specify an expiry or use qdb_never_expires if you don't want the\n! entry to expire.\n!\n! If you want to create or update an entry use \\ref qdb_int_update.\n!\n! The value will be correctly translated independently of the endianness\n! of the client's platform.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param integer The value to which the integer must be set.\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_update, \\ref qdb_int_get, \\ref qdb_int_add"]
    pub fn qdb_direct_int_put(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        integer: qdb_int_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Creates or updates a signed 64-bit integer.\n!\n! Atomically updates an entry of the given alias to the provided value.\n! If the entry doesn't exist, it will be created.\n! If the entry is not an integer, the function will return\n! \\ref qdb_e_incompatible_type.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! You can specify an expiry time or use qdb_never_expires if you don't\n! want the entry to expire.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param integer The value to which the integer must be set.\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_put, \\ref qdb_int_get, \\ref qdb_int_add"]
    pub fn qdb_direct_int_update(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        integer: qdb_int_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Retrieves the value of a signed 64-bit integer.\n!\n! Atomically retrieves the value of an existing 64-bit integer.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! If the entry is not an integer, the function will return\n! \\ref qdb_e_incompatible_type.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param integer A pointer to an integer that will receive the current\n! value of the entry, if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_put, \\ref qdb_int_update, \\ref qdb_int_add"]
    pub fn qdb_direct_int_get(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        integer: *mut qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup direct\n! \\brief Atomically increases or decreases a signed 64-bit integer.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! The specified entry will be atomically increased (or decreased)\n! according to the given addend value:\n!  - To increase the value, specify a positive addend\n!  - To decrease the value, specify a negative addend\n!\n! The function return the result of the operation.\n!\n! The entry must already exist.\n! If the entry is not an integer, the function will return\n! \\ref qdb_e_incompatible_type.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param addend The value to add to the existing value.\n!\n! \\param result A pointer to an integer that will receive the current\n! value of the entry, if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_put, \\ref qdb_int_update, \\ref qdb_int_get"]
    pub fn qdb_direct_int_add(
        handle: qdb_direct_handle_t,
        alias: *const ::std::os::raw::c_char,
        addend: qdb_int_t,
        result: *mut qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup prefix\n! \\brief Retrieves the list of all entries matching the provided prefix.\n!\n! This function bypasses the clustering mechanism and accesses the node\n! local storage. Entries in the local node storage are not accessible via\n! the regular API and vice versa.\n!\n! A prefix-based search will enable you to find all entries matching a\n! provided \\p prefix.\n!\n! This function returns the list of aliases. It's up to the user to query\n! the content associated with every entry, if needed.\n!\n! \\param handle A valid handle previously initialized by \\ref\n! qdb_direct_connect\n!\n! \\param prefix A pointer to a null-terminated UTF-8 string representing\n! the desired prefix\n!\n! \\param max_count An integer limiting the number of results returned by\n! the function\n!\n! \\param[out] results A pointer to a list of results\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_direct_prefix_get(
        handle: qdb_direct_handle_t,
        prefix: *const ::std::os::raw::c_char,
        max_count: qdb_int_t,
        results: *mut *mut *const ::std::os::raw::c_char,
        result_count: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup integer\n! \\brief Creates a new signed 64-bit integer.\n!\n! Atomically creates an entry of the given alias and sets it to a\n! cross-platform signed 64-bit integer.\n! If the entry already exists, the function returns an error.\n!\n! You can specify an expiry or use qdb_never_expires if you don't want the\n! entry to expire.\n!\n! If you want to create or update an entry use \\ref qdb_int_update.\n!\n! The value will be correctly translated independently of the endianness\n! of the client's platform.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param integer The value to which the integer must be set.\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_update, \\ref qdb_int_get, \\ref qdb_int_add"]
    pub fn qdb_int_put(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        integer: qdb_int_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup integer\n! \\brief Creates or updates a signed 64-bit integer.\n!\n! Atomically updates an entry of the given alias to the provided value.\n! If the entry doesn't exist, it will be created.\n! If the entry is not an integer, the function will return\n! \\ref qdb_e_incompatible_type.\n!\n! You can specify an expiry time or use qdb_never_expires if you don't\n! want the entry to expire.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param integer The value to which the integer must be set.\n!\n! \\param expiry_time An optional absolute expiry time expressed in UTC\n! UNIX epoch.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_put, \\ref qdb_int_get, \\ref qdb_int_add"]
    pub fn qdb_int_update(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        integer: qdb_int_t,
        expiry_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup integer\n! \\brief Retrieves the value of a signed 64-bit integer.\n!\n! Atomically retrieves the value of an existing 64-bit integer.\n!\n! If the entry is not an integer, the function will return\n! \\ref qdb_e_incompatible_type.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param integer A pointer to an integer that will receive the current\n! value of the entry, if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_put, \\ref qdb_int_update, \\ref qdb_int_add"]
    pub fn qdb_int_get(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        integer: *mut qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup integer\n! \\brief Atomically increases or decreases a signed 64-bit integer.\n!\n! The specified entry will be atomically increased (or decreased)\n! according to the given addend value:\n!  - To increase the value, specify a positive addend\n!  - To decrease the value, specify a negative addend\n!\n! The function return the result of the operation.\n!\n! The entry must already exist.\n! If the entry is not an integer, the function will return\n! \\ref qdb_e_incompatible_type.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry.\n!\n! \\param addend The value to add to the existing value.\n!\n! \\param result A pointer to an integer that will receive the current\n! value of the entry, if successful.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_int_put, \\ref qdb_int_update, \\ref qdb_int_get"]
    pub fn qdb_int_add(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        addend: qdb_int_t,
        result: *mut qdb_int_t,
    ) -> qdb_error_t;
}
#[doc = "! \\ingroup iterator\n! \\struct qdb_const_iterator_t\n! \\brief A read-only iterator on quasardb entries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_const_iterator_t {
    #[doc = "! The handle created with qdb_open"]
    pub handle: qdb_handle_t,
    #[doc = "! Opaque token, don't use"]
    pub token: *const ::std::os::raw::c_void,
    #[doc = "! Opaque pointer to internal structure, don't use"]
    pub node: *const ::std::os::raw::c_void,
    #[doc = "! Opaque pointer to reference, don't use"]
    pub ref_: *const ::std::os::raw::c_void,
    #[doc = "! The current alias of the entry"]
    pub alias: *const ::std::os::raw::c_char,
    #[doc = "! The content of the current entry"]
    pub content: *const ::std::os::raw::c_char,
    #[doc = "! The size of the content of the current entry"]
    pub content_size: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_const_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_const_iterator_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_const_iterator_t>(),
        56usize,
        concat!("Size of: ", stringify!(qdb_const_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_const_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_const_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_iterator_t),
            "::",
            stringify!(content_size)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup iterator\n! \\brief Creates an iterator that points to the \"first\" entry of the\n! cluster.\n!\n! This function enables you to iterate on all the entries of a cluster.\n! Keep in mind that there is no guarantee regarding the order of entries.\n!\n! The iteration occurs at a fixed point in time, operations occurring\n! after the iterator has been created will not be visible.\n!\n! Call \\ref qdb_iterator_next to go to the next available entry, if any.\n!\n! When iteration completes the function will return \\ref\n! qdb_e_iterator_end and the user must call \\ref qdb_iterator_close to\n! release client-allocated resources for the iteration.\n!\n! Iteration does not allocate any resource on the server.\n!\n! Whole cluster iteration is intended for some very specific use case. It\n! is greatly advised to use tags to work on subgroup of entries.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param iterator A pointer to an uninitialized iterator structure that\n! will be set to the first entry if successful\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_iterator_next, \\ref qdb_iterator_previous, \\ref\n! qdb_iterator_close"]
    pub fn qdb_iterator_begin(
        handle: qdb_handle_t,
        iterator: *mut qdb_const_iterator_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup iterator\n! \\brief Creates an iterator that points to the \"last\" entry of the\n! cluster.\n!\n! This function enables you to iterate on all the entries of a cluster.\n! Keep in mind that there is no guarantee regarding the order of entries.\n!\n! This works exactly like \\ref qdb_iterator_begin, excepts it starts at\n! the \"end\" of the cluster.\n!\n! Call \\ref qdb_iterator_previous to go to the previous available entry,\n! if any.\n!\n! See \\ref qdb_iterator_begin for more information.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param iterator A pointer to an uninitialized iterator structure that\n! will be set to the last entry if successful\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_iterator_begin, \\ref qdb_iterator_next, \\ref\n! qdb_iterator_previous, \\ref qdb_iterator_close"]
    pub fn qdb_iterator_rbegin(
        handle: qdb_handle_t,
        iterator: *mut qdb_const_iterator_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup iterator\n! \\brief Advances an iterator to the next entry, if any.\n!\n! Updates the iterator to point to the next available entry in the\n! cluster. Although each entry is returned only once, the order in which\n! entries are returned is undefined. If there is no following entry or it\n! is otherwise unavailable, the function will return \\ref\n! qdb_e_iterator_end.\n!\n! \\param iterator A pointer to a previously initialized iterator.\n!\n! \\see \\ref qdb_iterator_begin"]
    pub fn qdb_iterator_next(iterator: *mut qdb_const_iterator_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup iterator\n! \\brief Advances an iterator to the previous entry, if any.\n!\n! Updates the iterator to point to the previous available entry in the\n! cluster.\n! Although each entry is returned only once, the order in which entries\n! are returned is undefined. If there is no previous entry or it is\n! otherwise unavailable, the function will return \\ref qdb_e_iterator_end.\n!\n! \\param iterator A pointer to a previously initialized iterator.\n!\n! \\see \\ref qdb_iterator_begin"]
    pub fn qdb_iterator_previous(iterator: *mut qdb_const_iterator_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup iterator\n! \\brief Closes a previously initialized iterator and releases all\n! associated resources.\n!\n! \\param iterator A pointer to a previously initialized iterator.\n!\n! \\see \\ref qdb_iterator_rbegin, \\ref qdb_iterator_begin"]
    pub fn qdb_iterator_close(iterator: *mut qdb_const_iterator_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup iterator\n! \\brief Clones a previously initialized iterator.\n!\n! Copies the state of the original iterator to a new iterator. Both\n! iterators can afterward be independently operated. The cloned iterator\n! will have to be closed with \\ref qdb_iterator_close.\n!\n! \\see \\ref qdb_iterator_rbegin, \\ref qdb_iterator_begin, \\ref\n! qdb_iterator_close"]
    pub fn qdb_iterator_copy(
        original: *const qdb_const_iterator_t,
        copy: *mut qdb_const_iterator_t,
    ) -> qdb_error_t;
}
#[doc = "! Log everything. Very verbose."]
pub const qdb_log_level_t_qdb_log_detailed: qdb_log_level_t = 100;
#[doc = "! Log debug level messages and below"]
pub const qdb_log_level_t_qdb_log_debug: qdb_log_level_t = 200;
#[doc = "! Log information level messages and below"]
pub const qdb_log_level_t_qdb_log_info: qdb_log_level_t = 300;
#[doc = "! Log warning level messages and below"]
pub const qdb_log_level_t_qdb_log_warning: qdb_log_level_t = 400;
#[doc = "! Log error level messages and below"]
pub const qdb_log_level_t_qdb_log_error: qdb_log_level_t = 500;
#[doc = "! Log panic level messages and below. Very terse."]
pub const qdb_log_level_t_qdb_log_panic: qdb_log_level_t = 600;
#[doc = "! \\ingroup log\n! \\typedef qdb_log_level_t\n! \\brief An enumeration of log level\n! \\see \\ref qdb_open\n! \\see \\ref qdb_log_callback"]
pub type qdb_log_level_t = ::std::os::raw::c_uint;
#[doc = "! \\ingroup log\n! \\typedef qdb_log_callback_id\n! \\brief An unique callback identifier returned by \\ref\n! qdb_log_add_callback\n!\n! \\see \\ref qdb_log_add_callback, \\ref qdb_log_remove_callback"]
pub type qdb_log_callback_id = usize;
#[doc = "! \\ingroup log\n! \\typedef qdb_log_callback\n! \\brief A typedef representing a log callback\n!\n! \\see \\ref qdb_log_add_callback, \\ref qdb_log_remove_callback"]
pub type qdb_log_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: qdb_log_level_t,
        arg2: *const ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_ulong,
        arg5: *const ::std::os::raw::c_char,
        arg6: usize,
    ),
>;
extern "C" {
    #[doc = "! \\ingroup log\n! \\brief Adds a callback that will receive internal API log messages. This\n! can be used to incorporate internal API statuses in your log.\n!\n! \\param cb A callback of type \\ref qdb_log_callback. The callback will be\n! called every time the API emits a log message.\n!\n! \\param callback_id A pointer to an unique callback identifier that can\n! be used to remove the callback.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_log_callback, \\ref qdb_log_remove_callback"]
    pub fn qdb_log_add_callback(
        cb: qdb_log_callback,
        callback_id: *mut qdb_log_callback_id,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup log\n! \\brief Removes a previously added log callback.\n!\n! \\param callback_id The identifier set by \\ref qdb_log_add_callback that\n! will determine which callback to remove.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_log_callback, \\ref qdb_log_add_callback"]
    pub fn qdb_log_remove_callback(callback_id: qdb_log_callback_id) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup log\n! \\brief Indicates if logs are synchronized for each API call (disabled by\n! default).\n!\n! \\return 1 if logs are flushed before returning from each API call, 0\n!  otherwise.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_log_option_is_sync() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "! \\ingroup log\n! \\brief Set logs to be synchronous for each API call (disabled by\n! default).\n!\n! \\param sync_logger 1 if logs must be flushed before returning from each API call, 0\n!  otherwise.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_log_option_set_sync(sync_logger: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "! \\ingroup node\n! \\brief Returns the status of a node.\n!\n! The API will request the node for its status and allocate a buffer of\n! the appropriate size, which will later have to be released using \\ref\n! qdb_release.\n!\n! The status is JSON object and contains current information of the node\n! state, as described in the documentation.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A pointer to a null-terminated UTF-8 string representing the\n! URI of node for which the status is requested.\n!\n! \\param[out] content A pointer to the pointer of an API-allocated buffer\n! holding the node status.\n!\n! \\param[out] content_length A pointer to an integer representing the size\n! of the API-allocated buffer.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_node_status(
        handle: qdb_handle_t,
        uri: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_char,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup node\n! \\brief Returns the configuration of a node.\n!\n! The API will request the node for its configuration and allocate a\n! buffer of the appropriate size, which will later have to be released\n! using \\ref qdb_release.\n!\n! The configuration is JSON object, as described in the documentation.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A pointer to a null-terminated UTF-8 string representing the\n! URI of the node for which the configuration is requested.\n!\n! \\param[out] content A pointer to the pointer of an API-allocated buffer\n! holding the node configuration.\n!\n! \\param[out] content_length A pointer to an integer representing the size\n! of the API-allocated buffer.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_node_config(
        handle: qdb_handle_t,
        uri: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_char,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup node\n! \\brief Returns the topology of a node.\n!\n! The API will request the node for its topology and allocate a buffer of\n! the appropriate size, which will later have to be released using \\ref\n! qdb_release.\n!\n! The topology is JSON object containing the node address, and the\n! addresses of its successor and predecessor.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A pointer to a null-terminated UTF-8 string representing the\n! URI of node for which the topology is requested.\n!\n! \\param[out] content A pointer to the pointer of an API-allocated buffer\n! holding the node topology.\n!\n! \\param[out] content_length A pointer to an integer representing the size\n! of the API-allocated buffer.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_node_topology(
        handle: qdb_handle_t,
        uri: *const ::std::os::raw::c_char,
        content: *mut *const ::std::os::raw::c_char,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup node\n! \\brief Requests the node to gracefully stop.\n!\n! Use this function to remotely stop a node, the supplied reason will be\n! displayed in the logs of the remote node.\n!\n! By default cluster do not allow this operation and the function will\n! return \\ref qdb_e_operation_disabled error.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A pointer to a null-terminated UTF-8 string representing the\n! URI of node to be stopped.\n!\n! \\param reason A pointer to a null-terminated UTF-8 string of the reason\n! for the stop.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_node_stop(
        handle: qdb_handle_t,
        uri: *const ::std::os::raw::c_char,
        reason: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "!\n! Use this function to interrupt a running partition. A negative value\n! will interrupt all partitions on the node.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param uri A pointer to a null-terminated UTF-8 string representing the\n! URI of node to be stopped.\n!\n! \\param partition_number The partition number to interrupt. A negative\n! value interrupts all partitions.\n!\n! \\param period The maximum duration into which the interrupt will be\n! active, in milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_node_interrupt_partition(
        handle: qdb_handle_t,
        uri: *const ::std::os::raw::c_char,
        partition_number: qdb_int16_t,
        period: qdb_uint_t,
    ) -> qdb_error_t;
}
pub const qdb_perf_label_t_qdb_pl_undefined: qdb_perf_label_t = 0;
pub const qdb_perf_label_t_qdb_pl_accepted: qdb_perf_label_t = 1;
pub const qdb_perf_label_t_qdb_pl_received: qdb_perf_label_t = 2;
pub const qdb_perf_label_t_qdb_pl_secured: qdb_perf_label_t = 3;
pub const qdb_perf_label_t_qdb_pl_deserialization_starts: qdb_perf_label_t = 4;
pub const qdb_perf_label_t_qdb_pl_deserialization_ends: qdb_perf_label_t = 5;
pub const qdb_perf_label_t_qdb_pl_entering_chord: qdb_perf_label_t = 6;
pub const qdb_perf_label_t_qdb_pl_processing_starts: qdb_perf_label_t = 7;
pub const qdb_perf_label_t_qdb_pl_dispatch: qdb_perf_label_t = 8;
pub const qdb_perf_label_t_qdb_pl_serialization_starts: qdb_perf_label_t = 9;
pub const qdb_perf_label_t_qdb_pl_serialization_ends: qdb_perf_label_t = 10;
pub const qdb_perf_label_t_qdb_pl_processing_ends: qdb_perf_label_t = 11;
pub const qdb_perf_label_t_qdb_pl_replying: qdb_perf_label_t = 12;
pub const qdb_perf_label_t_qdb_pl_replied: qdb_perf_label_t = 13;
pub const qdb_perf_label_t_qdb_pl_entry_writing_starts: qdb_perf_label_t = 14;
pub const qdb_perf_label_t_qdb_pl_entry_writing_ends: qdb_perf_label_t = 15;
pub const qdb_perf_label_t_qdb_pl_content_reading_starts: qdb_perf_label_t = 16;
pub const qdb_perf_label_t_qdb_pl_content_reading_ends: qdb_perf_label_t = 17;
pub const qdb_perf_label_t_qdb_pl_content_writing_starts: qdb_perf_label_t = 18;
pub const qdb_perf_label_t_qdb_pl_content_writing_ends: qdb_perf_label_t = 19;
pub const qdb_perf_label_t_qdb_pl_directory_reading_starts: qdb_perf_label_t = 20;
pub const qdb_perf_label_t_qdb_pl_directory_reading_ends: qdb_perf_label_t = 21;
pub const qdb_perf_label_t_qdb_pl_directory_writing_starts: qdb_perf_label_t = 22;
pub const qdb_perf_label_t_qdb_pl_directory_writing_ends: qdb_perf_label_t = 23;
pub const qdb_perf_label_t_qdb_pl_entry_trimming_starts: qdb_perf_label_t = 24;
pub const qdb_perf_label_t_qdb_pl_entry_trimming_ends: qdb_perf_label_t = 25;
pub const qdb_perf_label_t_qdb_pl_ts_evaluating_starts: qdb_perf_label_t = 26;
pub const qdb_perf_label_t_qdb_pl_ts_evaluating_ends: qdb_perf_label_t = 27;
pub const qdb_perf_label_t_qdb_pl_ts_bucket_updating_starts: qdb_perf_label_t = 28;
pub const qdb_perf_label_t_qdb_pl_ts_bucket_updating_ends: qdb_perf_label_t = 29;
pub const qdb_perf_label_t_qdb_pl_affix_search_starts: qdb_perf_label_t = 30;
pub const qdb_perf_label_t_qdb_pl_affix_search_ends: qdb_perf_label_t = 31;
pub const qdb_perf_label_t_qdb_pl_eviction_starts: qdb_perf_label_t = 32;
pub const qdb_perf_label_t_qdb_pl_eviction_ends: qdb_perf_label_t = 33;
pub const qdb_perf_label_t_qdb_pl_time_vector_tracker_reading_starts: qdb_perf_label_t = 34;
pub const qdb_perf_label_t_qdb_pl_time_vector_tracker_reading_ends: qdb_perf_label_t = 35;
pub const qdb_perf_label_t_qdb_pl_bucket_reading_starts: qdb_perf_label_t = 36;
pub const qdb_perf_label_t_qdb_pl_bucket_reading_ends: qdb_perf_label_t = 37;
pub const qdb_perf_label_t_qdb_pl_entries_directory_reading_starts: qdb_perf_label_t = 38;
pub const qdb_perf_label_t_qdb_pl_entries_directory_reading_ends: qdb_perf_label_t = 39;
pub const qdb_perf_label_t_qdb_pl_acl_reading_starts: qdb_perf_label_t = 40;
pub const qdb_perf_label_t_qdb_pl_acl_reading_ends: qdb_perf_label_t = 41;
pub const qdb_perf_label_t_qdb_pl_time_vector_reading_starts: qdb_perf_label_t = 42;
pub const qdb_perf_label_t_qdb_pl_time_vector_reading_ends: qdb_perf_label_t = 43;
pub const qdb_perf_label_t_qdb_pl_unknown: qdb_perf_label_t = 255;
#[doc = "! \\ingroup perf\n! \\brief The possible labels for a performance measurement"]
pub type qdb_perf_label_t = ::std::os::raw::c_uint;
#[doc = "! \\ingroup perf\n! \\struct qdb_perf_measurement_t\n! \\brief A structure representing a performance measurement\n! database."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_perf_measurement_t {
    #[doc = "! \\brief Label of the measurement"]
    pub label: qdb_perf_label_t,
    #[doc = "! \\brief The number of nanoseconds elapsed since the first measurement"]
    pub elapsed: qdb_time_t,
}
#[test]
fn bindgen_test_layout_qdb_perf_measurement_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_perf_measurement_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_perf_measurement_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_perf_measurement_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_perf_measurement_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_perf_measurement_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_perf_measurement_t),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elapsed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_perf_measurement_t),
            "::",
            stringify!(elapsed)
        )
    );
}
#[doc = "! \\ingroup perf\n! \\struct qdb_perf_profile_t\n! \\brief A structure representing a continuous list of performance\n! measurements"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_perf_profile_t {
    #[doc = "! \\brief A name for the profile"]
    pub name: qdb_string_t,
    #[doc = "! \\brief Pointer to an array of measurements"]
    pub measurements: *mut qdb_perf_measurement_t,
    #[doc = "! \\brief The total number of measurements"]
    pub count: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_perf_profile_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_perf_profile_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_perf_profile_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_perf_profile_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_perf_profile_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_perf_profile_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_perf_profile_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measurements) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_perf_profile_t),
            "::",
            stringify!(measurements)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_perf_profile_t),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup perf\n! \\brief Gets the list of profiles for the the given handle.\n!\n! The profiles that have been extracted will be cleared in the given\n! handle. This means the next call to this function will return new\n! profile information only.\n!\n! The handle must be connected.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param profiles A pointer to a pointer of profiles list that will be\n! allocated by the API and must be release with qdb_release\n!\n! \\param count A pointer to an integer that will receive the number\n! of returned profiles.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_perf_get_profiles(
        handle: qdb_handle_t,
        profiles: *mut *mut qdb_perf_profile_t,
        count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup perf\n! \\brief Clears all accumulated profile information in the associated\n! handle\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_perf_clear_all_profiles(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup perf\n! \\brief Enables for all threads client side collection of performance\n! data sent by the server.\n!\n! By default the client will not store performance data returned by the\n! server.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_perf_enable_client_tracking(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup perf\n! \\brief Disables client side collection of performance data sent by the\n! server on the provided handle.\n!\n! By default the client will not store performance data returned by the\n! server.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_perf_disable_client_tracking(handle: qdb_handle_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup prefix\n! \\brief Retrieves the list of all entries matching the provided prefix.\n!\n! A prefix-based search will enable you to find all entries matching a\n! provided \\p prefix.\n!\n! This function returns the list of aliases. It's up to the user to query\n! the content associated with every entry, if needed.\n!\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param prefix A pointer to a null-terminated UTF-8 string representing\n! the desired prefix\n!\n! \\param max_count An integer limiting the number of results returned by\n! the function\n!\n! \\param[out] results A pointer to a list of results\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_prefix_get(
        handle: qdb_handle_t,
        prefix: *const ::std::os::raw::c_char,
        max_count: qdb_int_t,
        results: *mut *mut *const ::std::os::raw::c_char,
        result_count: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup prefix\n! \\brief Retrieves the count of all entries matching the provided prefix.\n!\n! A prefix-based count counts all entries matching a provided prefix.\n!\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param prefix A pointer to a null-terminated UTF-8 string representing\n! the desired prefix.\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_prefix_count(
        handle: qdb_handle_t,
        prefix: *const ::std::os::raw::c_char,
        result_count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup prefix\n! \\brief Retrieves the *approximate* count of all entries matching the\n! provided prefix.\n!\n! A prefix-based count counts all entries matching a provided prefix.\n!\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param prefix A pointer to a null-terminated UTF-8 string representing\n! the desired prefix.\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_prefix_approximate_count(
        handle: qdb_handle_t,
        prefix: *const ::std::os::raw::c_char,
        result_count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    const UNINIT: ::std::mem::MaybeUninit<__float2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    const UNINIT: ::std::mem::MaybeUninit<__double2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    const UNINIT: ::std::mem::MaybeUninit<exception> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief A timestamped data with a double-precision floating-point value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_double_point {
    #[doc = "! \\brief Timestamp."]
    pub timestamp: qdb_timespec_t,
    #[doc = "! \\brief Numeric value."]
    pub value: f64,
}
#[test]
fn bindgen_test_layout_qdb_ts_double_point() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_double_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_double_point>(),
        24usize,
        concat!("Size of: ", stringify!(qdb_ts_double_point))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_double_point>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_double_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_double_point),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_double_point),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief A timestamped data with a binary content."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_blob_point {
    #[doc = "! \\copydoc qdb_ts_double_point::timestamp"]
    pub timestamp: qdb_timespec_t,
    #[doc = "! Pointer to data."]
    pub content: *const ::std::os::raw::c_void,
    #[doc = "! Length, in bytes, of the data pointed to by \\ref content."]
    pub content_length: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_blob_point() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_blob_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_blob_point>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_ts_blob_point))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_blob_point>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_blob_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_point),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_point),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_point),
            "::",
            stringify!(content_length)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief A timestamped data with a signed 64-bit integer value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_int64_point {
    #[doc = "! \\brief Timestamp."]
    pub timestamp: qdb_timespec_t,
    #[doc = "! \\brief Numeric value."]
    pub value: qdb_int_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_int64_point() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_int64_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_int64_point>(),
        24usize,
        concat!("Size of: ", stringify!(qdb_ts_int64_point))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_int64_point>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_int64_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_point),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_point),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief A timestamped data with a signed 64-bit integer value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_timestamp_point {
    #[doc = "! \\brief Timestamp."]
    pub timestamp: qdb_timespec_t,
    #[doc = "! \\brief Numeric value."]
    pub value: qdb_timespec_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_timestamp_point() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_timestamp_point> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_timestamp_point>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_ts_timestamp_point))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_timestamp_point>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_timestamp_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_timestamp_point),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_timestamp_point),
            "::",
            stringify!(value)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief A timestamped data with a string content."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_string_point {
    #[doc = "! \\copydoc qdb_ts_double_point::timestamp"]
    pub timestamp: qdb_timespec_t,
    #[doc = "! Pointer to data."]
    pub content: *const ::std::os::raw::c_char,
    #[doc = "! Length, in bytes, of the data pointed to by \\ref content."]
    pub content_length: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_string_point() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_string_point> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_string_point>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_ts_string_point))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_string_point>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_string_point))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_point),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_point),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_point),
            "::",
            stringify!(content_length)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Time interval."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_range_t {
    #[doc = "! Beginning of the interval, inclusive."]
    pub begin: qdb_timespec_t,
    #[doc = "! End of the interval, exclusive."]
    pub end: qdb_timespec_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_range_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_range_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_range_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_ts_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_range_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_range_t),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_range_t),
            "::",
            stringify!(end)
        )
    );
}
#[doc = "!< The first (earliest) data point."]
pub const qdb_ts_aggregation_type_t_qdb_agg_first: qdb_ts_aggregation_type_t = 0;
#[doc = "!< The last (latest) data point."]
pub const qdb_ts_aggregation_type_t_qdb_agg_last: qdb_ts_aggregation_type_t = 1;
#[doc = "!< The data point with the smallest value."]
pub const qdb_ts_aggregation_type_t_qdb_agg_min: qdb_ts_aggregation_type_t = 2;
#[doc = "!< The data point with the largest value."]
pub const qdb_ts_aggregation_type_t_qdb_agg_max: qdb_ts_aggregation_type_t = 3;
#[doc = "!< The arithmetic mean (average)."]
pub const qdb_ts_aggregation_type_t_qdb_agg_arithmetic_mean: qdb_ts_aggregation_type_t = 4;
#[doc = "!< The harmonic mean."]
pub const qdb_ts_aggregation_type_t_qdb_agg_harmonic_mean: qdb_ts_aggregation_type_t = 5;
#[doc = "!< The geometric mean."]
pub const qdb_ts_aggregation_type_t_qdb_agg_geometric_mean: qdb_ts_aggregation_type_t = 6;
#[doc = "!< The quadratic mean (root mean squaer)."]
pub const qdb_ts_aggregation_type_t_qdb_agg_quadratic_mean: qdb_ts_aggregation_type_t = 7;
#[doc = "!< The number of data points."]
pub const qdb_ts_aggregation_type_t_qdb_agg_count: qdb_ts_aggregation_type_t = 8;
#[doc = "!< The sum of values."]
pub const qdb_ts_aggregation_type_t_qdb_agg_sum: qdb_ts_aggregation_type_t = 9;
#[doc = "!< The sum of squares of values."]
pub const qdb_ts_aggregation_type_t_qdb_agg_sum_of_squares: qdb_ts_aggregation_type_t = 10;
pub const qdb_ts_aggregation_type_t_qdb_agg_spread: qdb_ts_aggregation_type_t = 11;
#[doc = "!< The sample variance."]
pub const qdb_ts_aggregation_type_t_qdb_agg_sample_variance: qdb_ts_aggregation_type_t = 12;
#[doc = "!< The sample standard deviation."]
pub const qdb_ts_aggregation_type_t_qdb_agg_sample_stddev: qdb_ts_aggregation_type_t = 13;
#[doc = "!< The population variance."]
pub const qdb_ts_aggregation_type_t_qdb_agg_population_variance: qdb_ts_aggregation_type_t = 14;
#[doc = "!< The population standard deviation."]
pub const qdb_ts_aggregation_type_t_qdb_agg_population_stddev: qdb_ts_aggregation_type_t = 15;
#[doc = "!< The value with the smallest absolute value."]
pub const qdb_ts_aggregation_type_t_qdb_agg_abs_min: qdb_ts_aggregation_type_t = 16;
#[doc = "!< The value with the largest absolute value."]
pub const qdb_ts_aggregation_type_t_qdb_agg_abs_max: qdb_ts_aggregation_type_t = 17;
#[doc = "!< The product."]
pub const qdb_ts_aggregation_type_t_qdb_agg_product: qdb_ts_aggregation_type_t = 18;
#[doc = "!< The skewness (shape parameter)."]
pub const qdb_ts_aggregation_type_t_qdb_agg_skewness: qdb_ts_aggregation_type_t = 19;
#[doc = "!< The kurtosis (shape parameter)."]
pub const qdb_ts_aggregation_type_t_qdb_agg_kurtosis: qdb_ts_aggregation_type_t = 20;
#[doc = "!< Scalar (no aggregation)."]
pub const qdb_ts_aggregation_type_t_qdb_agg_none: qdb_ts_aggregation_type_t = 21;
pub const qdb_ts_aggregation_type_t_qdb_agg_distinct_count: qdb_ts_aggregation_type_t = 22;
pub const qdb_ts_aggregation_type_t_qdb_agg_adjacent_count: qdb_ts_aggregation_type_t = 29;
#[doc = "!< The sum of absolute values."]
pub const qdb_ts_aggregation_type_t_qdb_agg_sum_of_abs: qdb_ts_aggregation_type_t = 32;
pub const qdb_ts_aggregation_type_t_qdb_agg_sum_of_abs_changes: qdb_ts_aggregation_type_t = 33;
#[doc = "! \\ingroup ts\n! \\brief Types of aggregations that can be computed on a time series."]
pub type qdb_ts_aggregation_type_t = ::std::os::raw::c_uint;
#[doc = "! \\ingroup ts\n! \\brief Aggregation input and result for columns of blobs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_blob_aggregation_t {
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::type"]
    pub type_: qdb_ts_aggregation_type_t,
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::range"]
    pub range: qdb_ts_range_t,
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::count"]
    pub count: qdb_size_t,
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::result"]
    pub result: qdb_ts_blob_point,
}
#[test]
fn bindgen_test_layout_qdb_ts_blob_aggregation_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_blob_aggregation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_blob_aggregation_t>(),
        80usize,
        concat!("Size of: ", stringify!(qdb_ts_blob_aggregation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_blob_aggregation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_blob_aggregation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_aggregation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_aggregation_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_aggregation_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_blob_aggregation_t),
            "::",
            stringify!(result)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Aggregation input and result for columns of numeric\n! floating-point values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_double_aggregation_t {
    #[doc = "! The type of the aggregation to perform."]
    pub type_: qdb_ts_aggregation_type_t,
    #[doc = "! The time interval on which the aggregation should be executed."]
    pub range: qdb_ts_range_t,
    #[doc = "! \\brief If applicable, the number of datapoints on which aggregation\n! has been computed."]
    pub count: qdb_size_t,
    #[doc = "! \\brief The result of the aggregation."]
    pub result: qdb_ts_double_point,
}
#[test]
fn bindgen_test_layout_qdb_ts_double_aggregation_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_double_aggregation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_double_aggregation_t>(),
        72usize,
        concat!("Size of: ", stringify!(qdb_ts_double_aggregation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_double_aggregation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_double_aggregation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_double_aggregation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_double_aggregation_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_double_aggregation_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_double_aggregation_t),
            "::",
            stringify!(result)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Aggregation input and result for columns of numeric integer\n! values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_int64_aggregation_t {
    #[doc = "! The type of the aggregation to perform."]
    pub type_: qdb_ts_aggregation_type_t,
    #[doc = "! The time interval on which the aggregation should be executed."]
    pub range: qdb_ts_range_t,
    #[doc = "! \\brief If applicable, the number of datapoints on which aggregation\n! has been computed."]
    pub count: qdb_size_t,
    #[doc = "! \\brief The result of the aggregation."]
    pub result: qdb_ts_int64_point,
    pub exact_result: f64,
}
#[test]
fn bindgen_test_layout_qdb_ts_int64_aggregation_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_int64_aggregation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_int64_aggregation_t>(),
        80usize,
        concat!("Size of: ", stringify!(qdb_ts_int64_aggregation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_int64_aggregation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_int64_aggregation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_aggregation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_aggregation_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_aggregation_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_aggregation_t),
            "::",
            stringify!(result)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exact_result) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_int64_aggregation_t),
            "::",
            stringify!(exact_result)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Aggregation input and result for columns of strings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_string_aggregation_t {
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::type"]
    pub type_: qdb_ts_aggregation_type_t,
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::range"]
    pub range: qdb_ts_range_t,
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::count"]
    pub count: qdb_size_t,
    #[doc = "! \\copydoc qdb_ts_double_aggregation_t::result"]
    pub result: qdb_ts_string_point,
}
#[test]
fn bindgen_test_layout_qdb_ts_string_aggregation_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_string_aggregation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_string_aggregation_t>(),
        80usize,
        concat!("Size of: ", stringify!(qdb_ts_string_aggregation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_string_aggregation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_string_aggregation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_aggregation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_aggregation_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_aggregation_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_string_aggregation_t),
            "::",
            stringify!(result)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Aggregation input and result for columns of numeric integer\n! values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_timestamp_aggregation_t {
    #[doc = "! The type of the aggregation to perform."]
    pub type_: qdb_ts_aggregation_type_t,
    #[doc = "! The time interval on which the aggregation should be executed."]
    pub range: qdb_ts_range_t,
    #[doc = "! \\brief If applicable, the number of datapoints on which aggregation\n! has been computed."]
    pub count: qdb_size_t,
    #[doc = "! \\brief The result of the aggregation."]
    pub result: qdb_ts_timestamp_point,
}
#[test]
fn bindgen_test_layout_qdb_ts_timestamp_aggregation_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_timestamp_aggregation_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_timestamp_aggregation_t>(),
        80usize,
        concat!("Size of: ", stringify!(qdb_ts_timestamp_aggregation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_timestamp_aggregation_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_timestamp_aggregation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_timestamp_aggregation_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_timestamp_aggregation_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_timestamp_aggregation_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_timestamp_aggregation_t),
            "::",
            stringify!(result)
        )
    );
}
pub const qdb_ts_column_type_t_qdb_ts_column_uninitialized: qdb_ts_column_type_t = -1;
#[doc = "!< Column of floating point values."]
pub const qdb_ts_column_type_t_qdb_ts_column_double: qdb_ts_column_type_t = 0;
#[doc = "!< Column of binary data."]
pub const qdb_ts_column_type_t_qdb_ts_column_blob: qdb_ts_column_type_t = 1;
#[doc = "!< Column of signed 64-bit integer values."]
pub const qdb_ts_column_type_t_qdb_ts_column_int64: qdb_ts_column_type_t = 2;
pub const qdb_ts_column_type_t_qdb_ts_column_timestamp: qdb_ts_column_type_t = 3;
#[doc = "!< Column of string data."]
pub const qdb_ts_column_type_t_qdb_ts_column_string: qdb_ts_column_type_t = 4;
#[doc = "! \\ingroup ts\n! \\brief Types of time series columns."]
pub type qdb_ts_column_type_t = ::std::os::raw::c_int;
pub type qdb_duration_t = qdb_uint_t;
#[doc = "! \\ingroup ts\n! \\brief Index of a time series columns. Does not necessarily match the\n! column position at table creation due to modifications to the table\n! schema (by adding, renaming or removing columns)."]
pub type qdb_ts_column_index_t = qdb_uint_t;
#[doc = "! \\ingroup ts\n! \\brief Description of a time series column."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_column_info_t {
    #[doc = "! \\brief A pointer to a null-terminated UTF-8 string representing the\n! name of the column."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "! The type of the column."]
    pub type_: qdb_ts_column_type_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_column_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_column_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_column_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_ts_column_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_column_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_column_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_column_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_column_info_t),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Description of a batch column info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_batch_column_info_t {
    #[doc = "! \\brief A pointer to a null-terminated UTF-8 string representing the\n! name of the timeseries."]
    pub timeseries: *const ::std::os::raw::c_char,
    #[doc = "! \\brief A pointer to a null-terminated UTF-8 string representing the\n! name of the column."]
    pub column: *const ::std::os::raw::c_char,
    #[doc = "! \\brief The number of expected elements in one insertion."]
    pub elements_count_hint: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_batch_column_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_batch_column_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_batch_column_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(qdb_ts_batch_column_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_batch_column_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_ts_batch_column_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeseries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_column_info_t),
            "::",
            stringify!(timeseries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_column_info_t),
            "::",
            stringify!(column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements_count_hint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_column_info_t),
            "::",
            stringify!(elements_count_hint)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Description of a batch column that will not be checked."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_ts_batch_unchecked_column_info_t {
    #[doc = "! \\brief A pointer to a null-terminated UTF-8 string representing the\n! name of the timeseries."]
    pub timeseries: *const ::std::os::raw::c_char,
    #[doc = "! \\brief A pointer to a null-terminated UTF-8 string representing the\n! name of the column."]
    pub column: *const ::std::os::raw::c_char,
    #[doc = "! \\brief The column's data type."]
    pub column_type: qdb_ts_column_type_t,
    #[doc = "! \\brief The column's position in the timeseries."]
    pub column_index: qdb_int_t,
    #[doc = "! \\brief The timeseries's shard size."]
    pub shard_size: qdb_duration_t,
    #[doc = "! \\brief The number of expected elements in one insertion."]
    pub elements_count_hint: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_ts_batch_unchecked_column_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_ts_batch_unchecked_column_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_ts_batch_unchecked_column_info_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_ts_batch_unchecked_column_info_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_ts_batch_unchecked_column_info_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeseries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t),
            "::",
            stringify!(timeseries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t),
            "::",
            stringify!(column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t),
            "::",
            stringify!(column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t),
            "::",
            stringify!(column_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shard_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t),
            "::",
            stringify!(shard_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elements_count_hint) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_ts_batch_unchecked_column_info_t),
            "::",
            stringify!(elements_count_hint)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief A representation of binary data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_blob_t {
    #[doc = "! Pointer to data."]
    pub content: *const ::std::os::raw::c_void,
    #[doc = "! Length, in bytes, of the data pointed to by \\ref content."]
    pub content_length: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_blob_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_blob_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_blob_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_blob_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_blob_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_blob_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_blob_t),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_blob_t),
            "::",
            stringify!(content_length)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Column sent to the server in a batch."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdb_exp_batch_push_column_t {
    #[doc = "! The column name in UTF-8 format."]
    pub name: qdb_string_t,
    #[doc = "! The column data type, how it's stored client-side."]
    pub data_type: qdb_ts_column_type_t,
    pub data: qdb_exp_batch_push_column_t__bindgen_ty_1,
}
#[doc = "! The column content to send."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union qdb_exp_batch_push_column_t__bindgen_ty_1 {
    pub timestamps: *const qdb_timespec_t,
    pub strings: *const qdb_string_t,
    pub blobs: *const qdb_blob_t,
    pub ints: *const qdb_int_t,
    pub doubles: *const f64,
}
#[test]
fn bindgen_test_layout_qdb_exp_batch_push_column_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_exp_batch_push_column_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_exp_batch_push_column_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_exp_batch_push_column_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1),
            "::",
            stringify!(timestamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blobs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1),
            "::",
            stringify!(blobs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1),
            "::",
            stringify!(ints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t__bindgen_ty_1),
            "::",
            stringify!(doubles)
        )
    );
}
#[test]
fn bindgen_test_layout_qdb_exp_batch_push_column_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_exp_batch_push_column_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_exp_batch_push_column_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_exp_batch_push_column_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_exp_batch_push_column_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_exp_batch_push_column_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Schema of a column sent to the server in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_exp_batch_push_column_schema_t {
    #[doc = "! The column type, how it's stored server-side."]
    pub column_type: qdb_ts_column_type_t,
    #[doc = "! The column index."]
    pub index: qdb_ts_column_index_t,
    #[doc = "! The column symbol table (for symbol columns)."]
    pub symtable: qdb_string_t,
}
#[test]
fn bindgen_test_layout_qdb_exp_batch_push_column_schema_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_exp_batch_push_column_schema_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_exp_batch_push_column_schema_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_exp_batch_push_column_schema_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_exp_batch_push_column_schema_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_exp_batch_push_column_schema_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_schema_t),
            "::",
            stringify!(column_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_schema_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symtable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_column_schema_t),
            "::",
            stringify!(symtable)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Data of a table sent to the server in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_exp_batch_push_table_data_t {
    #[doc = "! The number of rows to send."]
    pub row_count: qdb_size_t,
    #[doc = "! The number of columns to send."]
    pub column_count: qdb_size_t,
    #[doc = "! The rows timestamps."]
    pub timestamps: *const qdb_timespec_t,
    #[doc = "! The table columns to send."]
    pub columns: *const qdb_exp_batch_push_column_t,
}
#[test]
fn bindgen_test_layout_qdb_exp_batch_push_table_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_exp_batch_push_table_data_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_exp_batch_push_table_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_exp_batch_push_table_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_exp_batch_push_table_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_exp_batch_push_table_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_data_t),
            "::",
            stringify!(row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_data_t),
            "::",
            stringify!(column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_data_t),
            "::",
            stringify!(timestamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_data_t),
            "::",
            stringify!(columns)
        )
    );
}
#[doc = "! Standard way of pushing values."]
pub const qdb_exp_batch_push_options_t_qdb_exp_batch_option_standard: qdb_exp_batch_push_options_t =
    0;
#[doc = "! Operation works with the duplicated data removing."]
pub const qdb_exp_batch_push_options_t_qdb_exp_batch_option_unique: qdb_exp_batch_push_options_t =
    1;
#[doc = "! \\ingroup ts\n! \\brief Ways of working with duplicated data in \\ref qdb_exp_batch_push."]
pub type qdb_exp_batch_push_options_t = ::std::os::raw::c_uint;
#[doc = "! \\ingroup ts\n! \\brief Data and metadata of a table sent to the server in a batch."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_exp_batch_push_table_t {
    #[doc = "! The table name in UTF-8 format."]
    pub name: qdb_string_t,
    #[doc = "! The table data."]
    pub data: qdb_exp_batch_push_table_data_t,
    #[doc = "! Field used by \\ref qdb_exp_batch_push_truncate. The ranges\n! specifying previous data to erase."]
    pub truncate_ranges: *const qdb_ts_range_t,
    #[doc = "! Field used by \\ref qdb_exp_batch_push_truncate. The number of\n! truncated ranges."]
    pub truncate_range_count: qdb_size_t,
    #[doc = "! Field used for controling work with duplicated data.\n! Except of \\ref qdb_exp_batch_push_truncate mode."]
    pub options: qdb_exp_batch_push_options_t,
    #[doc = "! Field used by \\ref qdb_exp_batch_option_unique. The column names\n! array for duplication check. If NULL then all columns will be\n! checked."]
    pub where_duplicate: *mut qdb_string_t,
    #[doc = "! Size of \\ref where_duplicate array."]
    pub where_duplicate_count: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_exp_batch_push_table_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_exp_batch_push_table_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_exp_batch_push_table_t>(),
        88usize,
        concat!("Size of: ", stringify!(qdb_exp_batch_push_table_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_exp_batch_push_table_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_exp_batch_push_table_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_ranges) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(truncate_ranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_range_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(truncate_range_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).where_duplicate) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(where_duplicate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).where_duplicate_count) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_t),
            "::",
            stringify!(where_duplicate_count)
        )
    );
}
#[doc = "! \\ingroup ts\n! \\brief Schema of a table sent to the server in a batch. Indexed by the\n! table and column names given in \\ref qdb_exp_batch_push_table_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_exp_batch_push_table_schema_t {
    #[doc = "! The table shard size."]
    pub shard_size: qdb_duration_t,
    #[doc = "! The table columns. The column count is given by the associated \\ref\n! qdb_exp_batch_push_table_t, at data.column_count."]
    pub columns: *const qdb_exp_batch_push_column_schema_t,
}
#[test]
fn bindgen_test_layout_qdb_exp_batch_push_table_schema_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_exp_batch_push_table_schema_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_exp_batch_push_table_schema_t>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_exp_batch_push_table_schema_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_exp_batch_push_table_schema_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_exp_batch_push_table_schema_t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shard_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_schema_t),
            "::",
            stringify!(shard_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_exp_batch_push_table_schema_t),
            "::",
            stringify!(columns)
        )
    );
}
#[doc = "! Standard way of pushing values, as a fully transactional operation."]
pub const qdb_exp_batch_push_mode_t_qdb_exp_batch_push_transactional: qdb_exp_batch_push_mode_t = 0;
#[doc = "! Truncate previous data in the given ranges from \\ref\n! qdb_exp_batch_push_table_t during the batch push transaction. Works\n! otherwise like \\ref qdb_exp_batch_push_transactional."]
pub const qdb_exp_batch_push_mode_t_qdb_exp_batch_push_truncate: qdb_exp_batch_push_mode_t = 1;
#[doc = "! Update timeseries buckets inplace.\n! Faster than \\ref qdb_exp_batch_push_transactional for small\n! incremental writes. However, does not modify different tables at\n! once and partial modifications are not rolled back."]
pub const qdb_exp_batch_push_mode_t_qdb_exp_batch_push_fast: qdb_exp_batch_push_mode_t = 2;
#[doc = "! Sent data are asynchronously updated by the server using \\ref\n! qdb_exp_batch_push_fast strategy. Faster than \\ref\n! qdb_exp_batch_push_fast when multiple clients are modifying the same\n! tables simultaneously. However, the data are generally not yet\n! inserted when the call returns."]
pub const qdb_exp_batch_push_mode_t_qdb_exp_batch_push_async: qdb_exp_batch_push_mode_t = 3;
#[doc = "! \\ingroup ts\n! \\brief Ways of pushing data to timeseries with \\ref qdb_exp_batch_push."]
pub type qdb_exp_batch_push_mode_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Creates a time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param shard_size_ms A duration representing the time-span of a single\n! shard (bucket) of the time series, in milliseconds.\n!\n! \\param columns An array of column descriptions that are to be\n! added to the time series.\n!\n! \\param column_count The number of columns to add.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_create(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        shard_size_ms: qdb_uint_t,
        columns: *const qdb_ts_column_info_t,
        column_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Appends columns to an existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param columns An array of column descriptions that are to be\n! added to the time series.\n!\n! \\param column_count The number of columns to append.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_insert_columns(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        columns: *const qdb_ts_column_info_t,
        column_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Returns all the columns of a time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param[out] columns A pointer to an array that will contain descriptions\n! of columns present in the time series.\n!\n! \\param[out] column_count A pointer to an integer that will receive the\n! number of columns.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_list_columns(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        columns: *mut *mut qdb_ts_column_info_t,
        column_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Returns the shard size of a time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param[out] shard_size shard size of the timeseries, in ms.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_shard_size(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        shard_size: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts blob points in a time series column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_blob_insert(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        values: *const qdb_ts_blob_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts blob points in a time series and erases given ranges in\n! the same transaction.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_blob_insert_truncate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        values: *const qdb_ts_blob_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts double points in a time series.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_double_insert(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        values: *const qdb_ts_double_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts double points in a time series and erases given ranges in\n! the same transaction.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_double_insert_truncate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        values: *const qdb_ts_double_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts int64 points in a time series.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_int64_insert(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        values: *const qdb_ts_int64_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts int64 points in a time series and erases given ranges in\n! the same transaction.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_int64_insert_truncate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        values: *const qdb_ts_int64_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts string points in a time series column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_string_insert(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        values: *const qdb_ts_string_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts string points in a time series and erases given ranges in\n! the same transaction.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_string_insert_truncate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        values: *const qdb_ts_string_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts timestamp points in a time series.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_timestamp_insert(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        values: *const qdb_ts_timestamp_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Inserts timestamp points in a time series and erases given ranges\n! in the same transaction.\n!\n! Time series are distributed across the cluster and support efficient\n! insertion anywhere within the time series as well as efficient lookup\n! based on time.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\param values An array of data points to be inserted.\n!\n! \\param value_count The number of data points to insert.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_timestamp_insert_truncate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        values: *const qdb_ts_timestamp_point,
        value_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves blobs in the specified range of the time series column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] points A pointer to an array that will contain data points\n! from all given ranges.\n!\n! \\param[out] point_count A pointer to an integer that will receive the\n! number of returned points.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_blob_get_ranges(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        points: *mut *mut qdb_ts_blob_point,
        point_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves doubles in the specified range of the time series\n! column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] points A pointer to an array that will contain data points\n! from all given ranges.\n!\n! \\param[out] point_count A pointer to an integer that will receive the\n! number of returned points.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_double_get_ranges(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        points: *mut *mut qdb_ts_double_point,
        point_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves 64-bit integers in the specified range of the time\n! series column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] points A pointer to an array that will contain data points\n! from all given ranges.\n!\n! \\param[out] point_count A pointer to an integer that will receive the\n! number of returned points.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_int64_get_ranges(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        points: *mut *mut qdb_ts_int64_point,
        point_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves strings in the specified range of the time series\n! column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] points A pointer to an array that will contain data points\n! from all given ranges.\n!\n! \\param[out] point_count A pointer to an integer that will receive the\n! number of returned points.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_string_get_ranges(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        points: *mut *mut qdb_ts_string_point,
        point_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves timestamps in the specified range of the time\n! series column.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] points A pointer to an array that will contain data points\n! from all given ranges.\n!\n! \\param[out] point_count A pointer to an integer that will receive the\n! number of returned points.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_timestamp_get_ranges(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        points: *mut *mut qdb_ts_timestamp_point,
        point_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Aggregate a sub-part of a blob column of the time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param[in,out] aggregations An array of structures representing the\n! aggregations to compute and their results.\n!\n! \\param aggregation_count The number of elements in the aggregations\n! array.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_ts_aggregation_type_t\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_blob_aggregate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        aggregations: *mut qdb_ts_blob_aggregation_t,
        aggregation_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Aggregate a sub-part of the double column of the time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param[in,out] aggregations An array of structures representing the\n! aggregations to compute and their results.\n!\n! \\param aggregation_count The number of elements in the aggregations\n! array.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_ts_aggregation_type_t"]
    pub fn qdb_ts_double_aggregate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        aggregations: *mut qdb_ts_double_aggregation_t,
        aggregation_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Aggregate a sub-part of the int64 column of the time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param[in,out] aggregations An array of structures representing the\n! aggregations to compute and their results.\n!\n! \\param aggregation_count The number of elements in the aggregations\n! array.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_ts_aggregation_type_t"]
    pub fn qdb_ts_int64_aggregate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        aggregations: *mut qdb_ts_int64_aggregation_t,
        aggregation_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Aggregate a sub-part of a string column of the time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param[in,out] aggregations An array of structures representing the\n! aggregations to compute and their results.\n!\n! \\param aggregation_count The number of elements in the aggregations\n! array.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_ts_aggregation_type_t\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_string_aggregate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        aggregations: *mut qdb_ts_string_aggregation_t,
        aggregation_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Aggregate a sub-part of the timestamp column of the time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param[in,out] aggregations An array of structures representing the\n! aggregations to compute and their results.\n!\n! \\param aggregation_count The number of elements in the aggregations\n! array.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_ts_aggregation_type_t"]
    pub fn qdb_ts_timestamp_aggregate(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        aggregations: *mut qdb_ts_timestamp_aggregation_t,
        aggregation_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves the timestamps, not the values, for a given timeseries\n! column or the aggregation of all columns.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on. If this pointer is NULL, all columns\n! will be aggregated in a single range.\n!\n! \\param ranges An array of ranges (intervals) for which timestamps\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] timestamps A pointer to an array that will contain\n! timestamps from all given ranges.\n!\n! \\param[out] timestamp_count A pointer to an integer that will receive\n! the number of returned timestamps.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_get_timestamps(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        timestamps: *mut *mut qdb_timespec_t,
        timestamp_count: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Erase all points in the specified range (left inclusive).\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param column A pointer to a null-terminated UTF-8 string representing\n! the name of the column to work on.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\param[out] erased_count A pointer to an integer that will receive the\n!                          number of erased points.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_erase_ranges(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        column: *const ::std::os::raw::c_char,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
        erased_count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_local_table_internal {
    _unused: [u8; 0],
}
#[doc = "! \\ingroup ts\n! \\typedef qdb_local_table_t\n! \\brief An opaque local table structure used for bulk insertions"]
pub type qdb_local_table_t = *mut qdb_local_table_internal;
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Initialize a local table for bulk insertion in time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param columns An array of column descriptions to which\n! data will be inserted.\n!\n! \\param column_count The number of columns.\n!\n! \\param[out] table A pointer to a local table that will be initialized if\n! the function returns successfully.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed.\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_local_table_init(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        columns: *const qdb_ts_column_info_t,
        column_count: qdb_size_t,
        table: *mut qdb_local_table_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of doubles indicated\n! by the given index.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of\n! columns in the call to \\ref qdb_ts_local_table_init used to\n! initialize table.\n!\n! \\param value A value to be set in the chosen column in the current row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_double(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        value: f64,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of integers indicated\n! by the given index.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of\n! columns in the call to \\ref qdb_ts_local_table_init used to\n! initialize table.\n!\n! \\param value A value to be set in the chosen column in the current row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_int64(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        value: qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of timestamps\n! indicated by the given index.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of\n! columns in the call to \\ref qdb_ts_local_table_init used to\n! initialize table.\n!\n! \\param value A pointer to the value to be set in the chosen column in\n! the current row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_timestamp(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        value: *const qdb_timespec_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of blobs indicated by\n!        the given index, copy data.\n!\n! The data will be copied and kept alive until the following \\ref\n! qdb_ts_push call returns.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of columns in the call to\n! \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param content A pointer to the data to be set in the chosen column in\n! the current row.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_blob(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of blobs indicated by\n!        the given index without copying data.\n!\n! The data will NOT be copied and the user must ensure that the buffer\n! pointed by \\p content is kept alive until the end of the corresponding\n! call to \\ref qdb_ts_push.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of columns in the call to\n! \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param content A pointer to the data to be set in the chosen column in\n! the current row. The pointed data must be kept alive until the following\n! \\ref qdb_ts_push call returns.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\note The data pointed to by \\p content must be kept alive until the\n!       following \\ref qdb_ts_push call returns.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_blob_no_copy(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of strings indicated\n! by the given index, copy data.\n!\n! The data will be copied and kept alive until the following \\ref\n! qdb_ts_push call returns.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of columns in the call to\n! \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param content A pointer to the data to be set in the chosen column in\n! the current row.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_string(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *const ::std::os::raw::c_char,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of strings indicated\n! by the given index without copying data.\n!\n! The data will NOT be copied and the user must ensure that the buffer\n! pointed by \\p content is kept alive until the end of the corresponding\n! call to \\ref qdb_ts_push.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column in which the value\n! should be set. The index is based on the order of columns in the call to\n! \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param content A pointer to the data to be set in the chosen column in\n! the current row. The pointed data must be kept alive until the following\n! \\ref qdb_ts_push call returns.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\note The data pointed to by \\p content must be kept alive until the\n!       following \\ref qdb_ts_push call returns.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_row_set_string_no_copy(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *const ::std::os::raw::c_char,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Append current row to the outcoming data buffer.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param timestamp The timestamp of all data points in the row to append.\n!\n! \\param[out] row_index A pointer to an integer that will receive the\n! index of the currently appended row. The index is counted since the call\n! to \\ref qdb_ts_local_table_init. The pointer may be null.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_table_row_append(
        table: qdb_local_table_t,
        timestamp: *const qdb_timespec_t,
        row_index: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Push all the appended rows to the database.\n!\n! All the rows that were appended using qdb_ts_table_row_append since the\n! last call to \\ref qdb_ts_push or \\ref qdb_ts_local_table_init will be\n! pushed.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_push(table: qdb_local_table_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves blob data from the current row at the specified\n! column.\n!\n! The retrieved data will be the copy of the internal data stored in \\ref\n! qdb_local_table_t, so the user must ensure to call \\ref qdb_release when\n! she/he no longer needs it in order to clean up the memory.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\param[out] content A non-null pointer to a variable that will hold the\n! retrieved data.\n!\n! \\param[out] content_length A non-null pointer to a variable that will\n! hold the size of the retrieved data.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_row_get_blob(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *mut *const ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves blob data from the current row at the specified\n! column without performing copy of data internal to data.\n!\n! The retrieved data will be valid only until the next call of \\ref\n! qdb_ts_table_get_ranges on the same \\ref qdb_local_table_t or until the\n! deallocation thereof. If you want to keep the retrieved data for a\n! longer time, you may call \\ref qdb_ts_row_get_blob instead or copy the\n! data yourself.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\param[out] content A non-null pointer to a variable that will hold the\n! retrieved data.\n!\n! \\param[out] content_length A non-null pointer to a variable that will\n! hold the size of the retrieved data.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed.\n!\n! \\see \\ref qdb_ts_table_get_ranges\n! \\see \\ref qdb_ts_row_get_blob"]
    pub fn qdb_ts_row_get_blob_no_copy(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *mut *const ::std::os::raw::c_void,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves string data from the current row at the specified\n! column.\n!\n! The retrieved data will be the copy of the internal data stored in \\ref\n! qdb_local_table_t, so the user must ensure to call \\ref qdb_release when\n! she/he no longer needs it in order to clean up the memory.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\param[out] content A non-null pointer to a variable that will hold the\n! retrieved data.\n!\n! \\param[out] content_length A non-null pointer to a variable that will\n! hold the size of the retrieved data.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_row_get_string(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *mut *const ::std::os::raw::c_char,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves string data from the current row at the specified\n! column without performing copy of data internal to data.\n!\n! The retrieved data will be valid only until the next call of \\ref\n! qdb_ts_table_get_ranges on the same \\ref qdb_local_table_t or until the\n! deallocation thereof. If you want to keep the retrieved data for a\n! longer time, you may call \\ref qdb_ts_row_get_string instead or copy the\n! data yourself.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\param[out] content A non-null pointer to a variable that will hold the\n! retrieved data.\n!\n! \\param[out] content_length A non-null pointer to a variable that will\n! hold the size of the retrieved data.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed.\n!\n! \\see \\ref qdb_ts_table_get_ranges\n! \\see \\ref qdb_ts_row_get_string"]
    pub fn qdb_ts_row_get_string_no_copy(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        content: *mut *const ::std::os::raw::c_char,
        content_length: *mut qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves double value from the current row at the specified\n! column.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param[out] value A non-null pointer to a double that will hold the\n! retrieved value.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_row_get_double(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        value: *mut f64,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves signed 64-bit integer value from the current row at the\n! specified column.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param[out] value A non-null pointer to a signed 64-bit integer that\n! will hold the retrieved value.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_row_get_int64(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        value: *mut qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieves timestamp value from the current row at the specified\n! column.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param column_index A zero-based index of the column from which the\n! value should be retrieved. The index is based on the order of columns in\n! the call to \\ref qdb_ts_local_table_init used to initialize table.\n!\n! \\param[out] value A non-null pointer to a timestamp that will hold the\n! retrieved value.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_invalid_iterator when \\ref qdb_ts_table_get_ranges has not\n! been called before calling this function.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_row_get_timestamp(
        table: qdb_local_table_t,
        column_index: qdb_size_t,
        value: *mut qdb_timespec_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Fetch data and advance to the next row.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param[out] timestamp A non-null pointer to a variable that will hold a\n! timestamp for the fetched row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_iterator_end when there are no more rows in the specified\n! ranges.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_table_next_row(
        table: qdb_local_table_t,
        timestamp: *mut qdb_timespec_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieve all the specified rows from the database.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_iterator_end when there are no more rows in the specified\n! ranges.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_table_get_ranges(
        table: qdb_local_table_t,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Retrieve shard by shard the specified rows from the database.\n! The table is then seen as it was then this function was called.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_local_table_init.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be retrieved.\n!\n! \\param range_count The number of ranges.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure. Returns\n! \\ref qdb_e_iterator_end when there are no more rows in the specified\n! ranges.\n!\n! \\warning This function is still under development. Performance and\n!          compatibility are not guaranteed."]
    pub fn qdb_ts_table_stream_ranges(
        table: qdb_local_table_t,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
    ) -> qdb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_batch_table_internal {
    _unused: [u8; 0],
}
#[doc = "! \\ingroup ts\n! \\typedef qdb_batch_table_t\n! \\brief An opaque batch table structure used for bulk insertions"]
pub type qdb_batch_table_t = *mut qdb_batch_table_internal;
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Initialize a batch table for bulk insertion in time series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param columns An array of columns descriptions to which\n! data will be inserted.\n!\n! \\param column_count The number of columns.\n!\n! \\param[out] table A pointer to a batch table that will be initialized if\n! the function returns successfully.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_batch_table_init(
        handle: qdb_handle_t,
        columns: *const qdb_ts_batch_column_info_t,
        column_count: qdb_size_t,
        table: *mut qdb_batch_table_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Initialize a batch table for bulk insertion in time series.\n!\n! The given information are assumed to be correct and describing existing\n! timseries columns.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param columns An array of unchecked columns descriptions to which\n! data will be inserted.\n!\n! \\param column_count The number of columns.\n!\n! \\param[out] table A pointer to a batch table that will be initialized if\n! the function returns successfully.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_batch_table_unchecked_init(
        handle: qdb_handle_t,
        columns: *const qdb_ts_batch_unchecked_column_info_t,
        column_count: qdb_size_t,
        table: *mut qdb_batch_table_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Add extra columns to a batch table for bulk insertion in time\n! series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param columns An array of columns descriptions to which\n! data will be inserted.\n!\n! \\param column_count The number of columns.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_batch_table_extra_columns(
        table: qdb_batch_table_t,
        columns: *const qdb_ts_batch_column_info_t,
        column_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Add extra columns to a batch table for bulk insertion in time\n! series.\n!\n! It is an error to call this function on a non existing time series.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param columns An array of columns descriptions to which\n! data will be inserted.\n!\n! \\param column_count The number of columns.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see \\ref qdb_release"]
    pub fn qdb_ts_batch_table_unchecked_extra_columns(
        table: qdb_batch_table_t,
        columns: *const qdb_ts_batch_unchecked_column_info_t,
        column_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Start a new row to the outcoming data buffer.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param timestamp The timestamp used while appending values.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_start_row(
        table: qdb_batch_table_t,
        timestamp: *const qdb_timespec_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of blobs.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param content A pointer to the data to be set in the chosen column.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\note The data pointed to by \\p content must be kept alive until the\n!       following \\ref qdb_ts_push call returns."]
    pub fn qdb_ts_batch_row_set_blob(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of blobs without\n! copying data.\n!\n! The data will NOT be copied and the user must ensure that the buffer\n! pointed by \\p content is kept alive until the end of the corresponding\n! call to \\ref qdb_ts_batch_push.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param content A pointer to the data to be set in the chosen column in\n! the current row. The pointed data must be kept alive until the following\n! \\ref qdb_ts_push call returns.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\note The data pointed to by \\p content must be kept alive until the\n!       following \\ref qdb_ts_push call returns."]
    pub fn qdb_ts_batch_row_set_blob_no_copy(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        content: *const ::std::os::raw::c_void,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of strings.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param content A pointer to the data to be set in the chosen column.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\note The data pointed to by \\p content must be kept alive until the\n!       following \\ref qdb_ts_push call returns."]
    pub fn qdb_ts_batch_row_set_string(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        content: *const ::std::os::raw::c_char,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of strings without\n! copying data.\n!\n! The data will NOT be copied and the user must ensure that the buffer\n! pointed by \\p content is kept alive until the end of the corresponding\n! call to \\ref qdb_ts_batch_push.\n!\n! \\param table A valid local table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param content A pointer to the data to be set in the chosen column in\n! the current row. The pointed data must be kept alive until the following\n! \\ref qdb_ts_push call returns.\n!\n! \\param content_length Length, in bytes, of the data pointed to by \\p\n! content.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\note The data pointed to by \\p content must be kept alive until the\n!       following \\ref qdb_ts_push call returns."]
    pub fn qdb_ts_batch_row_set_string_no_copy(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        content: *const ::std::os::raw::c_char,
        content_length: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of doubles.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param value A value to be set in the chosen column in the current row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_row_set_double(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        value: f64,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of integers.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param value A value to be set in the chosen column in the current row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_row_set_int64(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        value: qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Set a value in the current row in a column of timestamps.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the value you want to modify.\n!\n! \\param value A pointer to the value to be set in the chosen column in\n! the current row.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_row_set_timestamp(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        value: *const qdb_timespec_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Copy efficiently a buffer that will live until the next push.\n! Useful to avoid tracking temporary blob or string lifetimes.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param source_buffer A valid pointer to the buffer you want to copy.\n!\n! \\param source_buffer_size The buffer size.\n!\n! \\param[out] dest_buffer A pointer to access the copied buffer.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_copy_buffer(
        table: qdb_batch_table_t,
        source_buffer: *const ::std::os::raw::c_void,
        source_buffer_size: qdb_size_t,
        dest_buffer: *mut *const ::std::os::raw::c_void,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize and get direct access to a blob column\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param capacity A valid capacity to resize to.\n!\n! \\param timestamp A valid timestamp in the shard you wish to pin.\n!\n! \\param[out] timeoffsets A pointer to access the time offsets of the\n! column.\n!\n! \\param[out] data A pointer to access the blob data of the column.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_pin_blob_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        capacity: qdb_size_t,
        timestamp: *mut qdb_timespec_t,
        timeoffsets: *mut *mut qdb_time_t,
        data: *mut *mut qdb_blob_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize and get direct access to a double column\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param capacity A valid capacity to resize to.\n!\n! \\param timestamp A valid timestamp in the shard you wish to pin.\n!\n! \\param[out] timeoffsets A pointer to access the time offsets of the\n! column.\n!\n! \\param[out] data A pointer to access the double data of the column.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_pin_double_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        capacity: qdb_size_t,
        timestamp: *mut qdb_timespec_t,
        timeoffsets: *mut *mut qdb_time_t,
        data: *mut *mut f64,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize and get direct access to a int64 column\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param capacity A valid capacity to resize to.\n!\n! \\param timestamp A valid timestamp in the shard you wish to pin.\n!\n! \\param[out] timeoffsets A pointer to access the time offsets of the\n! column.\n!\n! \\param[out] data A pointer to access the int64 data of the column.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_pin_int64_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        capacity: qdb_size_t,
        timestamp: *mut qdb_timespec_t,
        timeoffsets: *mut *mut qdb_time_t,
        data: *mut *mut qdb_int_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize and get direct access to a string column\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param capacity A valid capacity to resize to.\n!\n! \\param timestamp A valid timestamp in the shard you wish to pin.\n!\n! \\param[out] timeoffsets A pointer to access the time offsets of the\n! column.\n!\n! \\param[out] data A pointer to access the string data of the column.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_pin_string_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        capacity: qdb_size_t,
        timestamp: *mut qdb_timespec_t,
        timeoffsets: *mut *mut qdb_time_t,
        data: *mut *mut qdb_string_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize and get direct access to a timestamp column\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param capacity A valid capacity to resize to.\n!\n! \\param timestamp A valid timestamp in the shard you wish to pin.\n!\n! \\param[out] timeoffsets A pointer to access the time offsets of the\n! column.\n!\n! \\param[out] data A pointer to access the timestamp data of the column.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_pin_timestamp_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        capacity: qdb_size_t,
        timestamp: *mut qdb_timespec_t,
        timeoffsets: *mut *mut qdb_time_t,
        data: *mut *mut qdb_timespec_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize the column without invalidating the pointers\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param size A valid size to shrink to.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_shrink_pinned_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        size: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Resize the column with no guarantee the pointers will not be\n! invalidated\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param index A valid index to the column you want to access.\n!\n! \\param size A valid size to resize to.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_unsafe_resize_pinned_column(
        table: qdb_batch_table_t,
        index: qdb_size_t,
        size: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Release memory of all cached columns. The tables metadata\n! are kept.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_release_columns_memory(table: qdb_batch_table_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Push the current batch table.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_push(table: qdb_batch_table_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Push the current batch table, non transactional.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_push_fast(table: qdb_batch_table_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Push asynchronously the current batch table.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_push_async(table: qdb_batch_table_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Push the current batch table, erasing previously stored points in\n! the given ranges, transactionally.\n!\n! \\param table A valid batch table previously initialized by\n! \\ref qdb_ts_batch_table_init.\n!\n! \\param ranges An array of ranges (intervals) for which data\n! should be erased.\n!\n! \\param range_count The number of ranges.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_batch_push_truncate(
        table: qdb_batch_table_t,
        ranges: *const qdb_ts_range_t,
        range_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Push the tables content to the server. Sort given rows if needed.\n! Write table info if asked.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param tables The tables to send.\n!\n! \\param table_schemas An optional pointer to the tables schema:\n!  - if it's null, the tables schema will be retrieved from the server.\n!  - if the underlying pointer is null, the tables schema will also be\n!  retrieved from the server, and exported to the given pointer. It must\n!  then released with \\ref qdb_release.\n!  - it the underlying pointer is not null, it will assume the given\n!  schema and not verifying it with the server before sending tables\n!  content.\n!\n! \\param table_count The number of tables.\n!\n! \\param mode Specifies how the data are pushed.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_exp_batch_push(
        handle: qdb_handle_t,
        mode: qdb_exp_batch_push_mode_t,
        tables: *const qdb_exp_batch_push_table_t,
        table_schemas: *mut *const qdb_exp_batch_push_table_schema_t,
        table_count: qdb_size_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Trim the timeseries, so that it uses approximately the provided\n! size.\n!\n! Trimming is done starting from the oldest entries, so that the most\n! recent shards are retained in the database.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param size The desired disk usage size after the operation, in bytes.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_ts_expire_by_size(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        size: qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Remove the given shard.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param reference A pointer to a shard reference.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! @see \\ref qdb_ts_bucket_base_time, \\ref qdb_ts_bucket_nuke_by_name"]
    pub fn qdb_ts_bucket_nuke_by_id(
        handle: qdb_handle_t,
        reference: *const qdb_id_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup ts\n! \\brief Remove the given shard.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param table A pointer to a null-terminated UTF-8 string representing\n! the alias of the time series.\n!\n! \\param shard_base_time The base time of the shard to remove, in\n! milliseconds.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! @see \\ref qdb_ts_bucket_base_time, \\ref qdb_ts_bucket_nuke_by_id"]
    pub fn qdb_ts_bucket_nuke_by_name(
        handle: qdb_handle_t,
        table: *const ::std::os::raw::c_char,
        shard_base_time: qdb_time_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Retrieves all entries' aliases that match the specified find\n! query.\n!\n! For the complete grammar, please refer to the documentation.\n!\n! Queries are transactional.\n!\n! The complexity of this function is dependent on the complexity of the\n! query.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param query A pointer to a null-terminated UTF-8 string representing\n! the query to perform.\n!\n! \\param[out] aliases A pointer to an array of null-terminated UTF-8\n! string that will list the aliases of the entries matching the query.\n!\n! \\param[out] alias_count A pointer to an integer that will receive the\n! number of returned aliases.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_query_find(
        handle: qdb_handle_t,
        query: *const ::std::os::raw::c_char,
        aliases: *mut *mut *const ::std::os::raw::c_char,
        alias_count: *mut usize,
    ) -> qdb_error_t;
}
pub const qdb_query_result_value_type_t_qdb_query_result_none: qdb_query_result_value_type_t = -1;
pub const qdb_query_result_value_type_t_qdb_query_result_double: qdb_query_result_value_type_t = 0;
pub const qdb_query_result_value_type_t_qdb_query_result_blob: qdb_query_result_value_type_t = 1;
pub const qdb_query_result_value_type_t_qdb_query_result_int64: qdb_query_result_value_type_t = 2;
pub const qdb_query_result_value_type_t_qdb_query_result_timestamp: qdb_query_result_value_type_t =
    3;
pub const qdb_query_result_value_type_t_qdb_query_result_count: qdb_query_result_value_type_t = 4;
pub const qdb_query_result_value_type_t_qdb_query_result_string: qdb_query_result_value_type_t = 5;
#[doc = "! \\ingroup query\n! \\brief The type of a result"]
pub type qdb_query_result_value_type_t = ::std::os::raw::c_int;
#[doc = "! \\ingroup query\n! \\brief A variadic structure holding the result type as well as the\n! result value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdb_point_result_t {
    pub type_: qdb_query_result_value_type_t,
    pub payload: qdb_point_result_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qdb_point_result_t__bindgen_ty_1 {
    pub double_: qdb_point_result_t__bindgen_ty_1__bindgen_ty_1,
    pub int64_: qdb_point_result_t__bindgen_ty_1__bindgen_ty_2,
    pub blob: qdb_point_result_t__bindgen_ty_1__bindgen_ty_3,
    pub timestamp: qdb_point_result_t__bindgen_ty_1__bindgen_ty_4,
    pub count: qdb_point_result_t__bindgen_ty_1__bindgen_ty_5,
    pub string: qdb_point_result_t__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_point_result_t__bindgen_ty_1__bindgen_ty_1 {
    pub value: f64,
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_point_result_t__bindgen_ty_1__bindgen_ty_2 {
    pub value: qdb_int_t,
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_point_result_t__bindgen_ty_1__bindgen_ty_3 {
    pub content: *const ::std::os::raw::c_void,
    pub content_length: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(content_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_point_result_t__bindgen_ty_1__bindgen_ty_4 {
    pub value: qdb_timespec_t,
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_point_result_t__bindgen_ty_1__bindgen_ty_5 {
    pub value: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_point_result_t__bindgen_ty_1__bindgen_ty_6 {
    pub content: *const ::std::os::raw::c_char,
    pub content_length: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(content_length)
        )
    );
}
#[test]
fn bindgen_test_layout_qdb_point_result_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(qdb_point_result_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_point_result_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).double_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1),
            "::",
            stringify!(double_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int64_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1),
            "::",
            stringify!(int64_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1),
            "::",
            stringify!(blob)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
}
#[test]
fn bindgen_test_layout_qdb_point_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_point_result_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_point_result_t>(),
        24usize,
        concat!("Size of: ", stringify!(qdb_point_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_point_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_point_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_point_result_t),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = "! \\ingroup query\n! \\brief Holds the result of a query"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_query_result_t {
    #[doc = "! An array of null terminated strings representing the returned\n! columns"]
    pub column_names: *mut qdb_string_t,
    #[doc = "! The count of returned columns"]
    pub column_count: qdb_size_t,
    #[doc = "! A two dimensional array of rows, values are acceded as such:\n!  rows[row_index][col_index]"]
    pub rows: *mut *mut qdb_point_result_t,
    #[doc = "! The number of returned rows"]
    pub row_count: qdb_size_t,
    #[doc = "! The number of scanned points, for information purposes\n! The actual number of scanned points may be greater"]
    pub scanned_point_count: qdb_size_t,
    #[doc = "! An optional, detailed error message about the query failure"]
    pub error_message: qdb_string_t,
}
#[test]
fn bindgen_test_layout_qdb_query_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_query_result_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_query_result_t>(),
        56usize,
        concat!("Size of: ", stringify!(qdb_query_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_query_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_query_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_names) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_result_t),
            "::",
            stringify!(column_names)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_result_t),
            "::",
            stringify!(column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_result_t),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_result_t),
            "::",
            stringify!(row_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scanned_point_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_result_t),
            "::",
            stringify!(scanned_point_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_message) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_result_t),
            "::",
            stringify!(error_message)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Run the provided query and creates a table directory with the\n! results.\n!\n! For the complete grammar, please refer to the documentation.\n!\n! Queries are transactional.\n!\n! The complexity of this function is dependent on the complexity of the\n! query.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param query A pointer to a null-terminated UTF-8 string representing\n! the query to perform.\n!\n! \\param[out] result A pointer to a pointer of qdb_query_result_t that\n! will receive the results. It must be released later with qdb_release.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release, \\ref qdb_option_set_client_max_parallelism"]
    pub fn qdb_query(
        handle: qdb_handle_t,
        query: *const ::std::os::raw::c_char,
        result: *mut *mut qdb_query_result_t,
    ) -> qdb_error_t;
}
#[doc = "! \\ingroup query\n! \\brief Holds a column of an experimental query\n!\n! \\warning This structure is still under development. Compatibility is not\n! guaranteed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdb_query_experimental_column_t {
    #[doc = "! The column name"]
    pub name: qdb_string_t,
    #[doc = "! The column values type"]
    pub type_: qdb_ts_column_type_t,
    pub data: qdb_query_experimental_column_t__bindgen_ty_1,
}
#[doc = "! The column values"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union qdb_query_experimental_column_t__bindgen_ty_1 {
    pub blobs: *mut qdb_blob_t,
    pub strings: *mut qdb_string_t,
    pub timestamps: *mut qdb_timespec_t,
    pub ints: *mut qdb_int_t,
    pub doubles: *mut f64,
}
#[test]
fn bindgen_test_layout_qdb_query_experimental_column_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_query_experimental_column_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_query_experimental_column_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_query_experimental_column_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blobs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1),
            "::",
            stringify!(blobs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamps) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1),
            "::",
            stringify!(timestamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1),
            "::",
            stringify!(ints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t__bindgen_ty_1),
            "::",
            stringify!(doubles)
        )
    );
}
#[test]
fn bindgen_test_layout_qdb_query_experimental_column_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_query_experimental_column_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_query_experimental_column_t>(),
        32usize,
        concat!("Size of: ", stringify!(qdb_query_experimental_column_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_query_experimental_column_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_query_experimental_column_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_column_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "! \\ingroup query\n! \\brief Holds the result of an experimental query\n!\n! \\warning This structure is still under development. Compatibility is not\n! guaranteed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_query_experimental_result_t {
    #[doc = "! An array containing the table columns"]
    pub columns: *mut qdb_query_experimental_column_t,
    #[doc = "! The count of returned columns"]
    pub column_count: qdb_size_t,
    #[doc = "! The number of returned rows"]
    pub row_count: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_query_experimental_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_query_experimental_result_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_query_experimental_result_t>(),
        24usize,
        concat!("Size of: ", stringify!(qdb_query_experimental_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_query_experimental_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_query_experimental_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_result_t),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_result_t),
            "::",
            stringify!(column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_experimental_result_t),
            "::",
            stringify!(row_count)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Run the provided query to return a table.\n!\n! Currently only supports querying some columns of a timeseries.\n!\n! Queries are transactional.\n!\n! The complexity of this function is dependent on the complexity of the\n! query.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param query A pointer to a null-terminated UTF-8 string representing\n! the query to perform.\n!\n! \\param[out] result A pointer to a pointer of qdb_query_result_t that\n! will receive the results. It must be released later with qdb_release.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release\n!\n! \\warning This function is still under development. Performance and\n! compatibility are not guaranteed."]
    pub fn qdb_query_experimental(
        handle: qdb_handle_t,
        query: *const ::std::os::raw::c_char,
        result: *mut *mut qdb_query_experimental_result_t,
    ) -> qdb_error_t;
}
#[doc = "! \\ingroup query\n! \\brief Holds a column of a query result in Arrow format\n!\n! \\warning This structure is still under development. Compatibility is not\n! guaranteed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_query_arrow_column_t {
    #[doc = "! The column name"]
    pub name: qdb_string_t,
    #[doc = "! The column type"]
    pub schema: ArrowSchema,
    #[doc = "! The column content"]
    pub array: ArrowArray,
}
#[test]
fn bindgen_test_layout_qdb_query_arrow_column_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_query_arrow_column_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_query_arrow_column_t>(),
        168usize,
        concat!("Size of: ", stringify!(qdb_query_arrow_column_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_query_arrow_column_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_query_arrow_column_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_arrow_column_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schema) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_arrow_column_t),
            "::",
            stringify!(schema)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_arrow_column_t),
            "::",
            stringify!(array)
        )
    );
}
#[doc = "! \\ingroup query\n! \\brief Holds the result of a query in Arrow format\n!\n! \\warning This structure is still under development. Compatibility is not\n! guaranteed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_query_arrow_result_t {
    #[doc = "! An array containing the table columns"]
    pub columns: *mut qdb_query_arrow_column_t,
    #[doc = "! The count of returned columns"]
    pub column_count: qdb_size_t,
    #[doc = "! The number of returned rows"]
    pub row_count: qdb_size_t,
}
#[test]
fn bindgen_test_layout_qdb_query_arrow_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_query_arrow_result_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_query_arrow_result_t>(),
        24usize,
        concat!("Size of: ", stringify!(qdb_query_arrow_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_query_arrow_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_query_arrow_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).columns) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_arrow_result_t),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).column_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_arrow_result_t),
            "::",
            stringify!(column_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_query_arrow_result_t),
            "::",
            stringify!(row_count)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Copies a query result to the Arrow format\n!\n! The allocated results have to be released later with \\ref qdb_release.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param result A pointer to a query result to clone\n!\n! \\param[out] result_copy A pointer to a a pointer that will receive\n! API-allocated results whose content will be a copy of the source results\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_query_to_arrow(
        handle: qdb_handle_t,
        result: *const qdb_query_result_t,
        result_copy: *mut *mut qdb_query_arrow_result_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Copies a query result to the Arrow format\n!\n! The allocated results have to be released later with \\ref qdb_release.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param result A pointer to a query result to clone\n!\n! \\param[out] result_copy A pointer to a a pointer that will receive\n! API-allocated results whose content will be a copy of the source results\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_query_experimental_to_arrow(
        handle: qdb_handle_t,
        result: *const qdb_query_experimental_result_t,
        result_copy: *mut *mut qdb_query_arrow_result_t,
    ) -> qdb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_dedup_handle_internal {
    _unused: [u8; 0],
}
#[doc = "! \\ingroup query\n! \\typedef qdb_dedup_handle_t\n! \\brief An opaque handle to internal API-allocated structures needed for\n! deduplicating query results."]
pub type qdb_dedup_handle_t = *mut qdb_dedup_handle_internal;
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Creates a \\ref qdb_dedup_handle_t.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param[out] dedup_handle A pointer to a \\ref qdb_dedup_handle_t that\n! will be ready for deduplicating query results. It must be released later\n! with qdb_release.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_init_query_dedup(
        handle: qdb_handle_t,
        dedup_handle: *mut qdb_dedup_handle_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Deduplicates query results.\n!\n! Rows already seen by previous calls to qdb_query_dedup for the given\n! deduplication handler will not be included in the deduplicated results.\n!\n! \\param dedup_handle A valid deduplication handle previously initialized\n! by \\ref qdb_init_query_dedup.\n!\n! \\param result A pointer to a qdb_query_result_t that holds the results\n! from a previous call to \\ref qdb_query. Results given to a deduplication\n! filter must all come from the same query, but different ranges or where\n! clauses are allowed.\n!\n! \\param[out] dedup_result A pointer to a pointer of qdb_query_result_t\n! that will receive the deduplicated results. It must be released later\n! with qdb_release.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_query_dedup(
        dedup_handle: qdb_dedup_handle_t,
        result: *const qdb_query_result_t,
        dedup_result: *mut *mut qdb_query_result_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Removes previously seen rows from the given deduplication\n! handler.\n!\n! \\param dedup_handle A valid deduplication handle previously initialized\n! by \\ref qdb_init_query_dedup. If the $timestamp special column hasn't\n! been selected all rows are removed.\n!\n! \\param range A pointer to a qdb_ts_range_t (interval) for which rows\n! should be removed.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_query_dedup_prune(
        dedup_handle: qdb_dedup_handle_t,
        range: *const qdb_ts_range_t,
    ) -> qdb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_query_cont_internal {
    _unused: [u8; 0],
}
#[doc = "! \\ingroup query\n! \\typedef qdb_query_cont_handle_t\n! \\brief An opaque handle to internal API-allocated structures needed for\n! managing a continuous query"]
pub type qdb_query_cont_handle_t = *mut qdb_query_cont_internal;
#[doc = "! \\ingroup query\n! \\typedef qdb_query_cont_callback_t\n! \\brief A callback used by qdb_query_continuous.\n! The first parameter of the callback will receive the context given\n! when calling qdb_query_continuous\n! The second parameter is the error result of the operation\n! The third parameter are the new results for the query since the\n! callback has been last called\n! \\see qdb_query_continuous"]
pub type qdb_query_cont_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: qdb_error_t,
        arg3: *const qdb_query_result_t,
    ) -> ::std::os::raw::c_int,
>;
pub const qdb_query_continuous_mode_type_t_qdb_query_continuous_full:
    qdb_query_continuous_mode_type_t = 0;
pub const qdb_query_continuous_mode_type_t_qdb_query_continuous_new_values_only:
    qdb_query_continuous_mode_type_t = 1;
#[doc = "! \\ingroup query\n! \\brief The continuous query mode"]
pub type qdb_query_continuous_mode_type_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "! \\ingroup query\n! \\brief Continuously and efficiently query the server with the given\n! query\n!\n! A continuous query receives results in a callback asynchronously as they\n! are available on the server. This API uses push notifications from the\n! server to minimize data exchange and resource usage.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param query A pointer to a null-terminated UTF-8 string representing\n! the query to perform. Any valid QuasarDB query is supported.\n!\n! \\param mode The mode of the query. Full will return all values at every\n! call whereas new values will only deliver updates values.\n!\n! \\param cb A pointer to a function that will be called when new data is\n! available\n!\n! \\param cb_context An opaque pointer to any client managed structure to\n! pass to the callback. May be null if no context is needed.\n!\n! \\param[out] cont_handle A handle to the continuous query handle. Updates\n! to the query will be received until qdb_release is called on this\n! handle.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n! \\see qdb_release"]
    pub fn qdb_query_continuous(
        handle: qdb_handle_t,
        query: *const ::std::os::raw::c_char,
        mode: qdb_query_continuous_mode_type_t,
        cb: qdb_query_cont_callback_t,
        cb_context: *mut ::std::os::raw::c_void,
        cont_handle: *mut qdb_query_cont_handle_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup suffix\n! \\brief Retrieves the list of all entries matching the provided suffix.\n!\n! A suffix-based search will enable you to find all entries matching a\n! provided \\p suffix.\n!\n! This function returns the list of aliases. It's up to the user to query\n! the content associated with every entry, if needed.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param suffix A pointer to a null-terminated UTF-8 string representing\n! the desired suffix\n!\n! \\param max_count An integer limiting the number of results returned by\n! the function\n!\n! \\param[out] results A pointer to a list of results\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_release"]
    pub fn qdb_suffix_get(
        handle: qdb_handle_t,
        suffix: *const ::std::os::raw::c_char,
        max_count: qdb_int_t,
        results: *mut *mut *const ::std::os::raw::c_char,
        result_count: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup suffix\n! \\brief Retrieves the count of all entries matching the provided suffix.\n!\n! A suffix-based count counts all entries matching a provided suffix.\n!\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param suffix A pointer to a null-terminated UTF-8 string representing\n! the desired suffix\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_suffix_count(
        handle: qdb_handle_t,
        suffix: *const ::std::os::raw::c_char,
        result_count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup suffix\n! \\brief Retrieves the *approximate* count of all entries matching the\n! provided suffix.\n!\n! A suffix-based count counts all entries matching a provided suffix.\n!\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param suffix A pointer to a null-terminated UTF-8 string representing\n! the desired suffix\n!\n! \\param[out] result_count A pointer to an integer giving the results\n! count\n!\n! \\return A \\ref qdb_error_t code indicating success or failure."]
    pub fn qdb_suffix_approximate_count(
        handle: qdb_handle_t,
        suffix: *const ::std::os::raw::c_char,
        result_count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Adds a tag to an entry\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The entry must exist.\n!\n! The tag may or may not exist.\n!\n! Consider using \\ref qdb_attach_tags if you are adding several tags to\n! the same entry.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry to which the tag must be added.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag to add to the entry\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_attach_tags, \\ref qdb_has_tag, \\ref qdb_detach_tag, \\ref\n! qdb_get_tagged, \\ref qdb_get_tags"]
    pub fn qdb_attach_tag(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        tag: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Adds a collection of tags to a single entry.\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The function will ignore existing tags.\n!\n! The entry must exist.\n!\n! The tag may or may not exist.\n!\n! Consider using \\ref qdb_attach_tag if you are adding a single tag.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry to which the tags must be added.\n!\n! \\param tags A pointer to an array of null-terminated UTF-8 strings\n! representing the tags to add to the entry\n!\n! \\param tag_count The count of tags to add to the entry.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_attach_tag, \\ref qdb_has_tag, \\ref qdb_detach_tags, \\ref\n! qdb_get_tagged, \\ref qdb_get_tags"]
    pub fn qdb_attach_tags(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        tags: *const *const ::std::os::raw::c_char,
        tag_count: usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Tests if an entry has the request tag.\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The entry must exist.\n!\n! If you need to test several entries and/or several tags, consider using\n! a batch for maximum performance.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry to which the tag must be tested.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag for which presence must be tested\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tagged, \\ref qdb_get_tags, \\ref qdb_run_batch"]
    pub fn qdb_has_tag(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        tag: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Removes a tag from an entry\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The entry must exist.\n!\n! The tag must exist.\n!\n! Consider using \\ref qdb_detach_tags if you are removing several tags at\n! once.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry to which the tag must be remove.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag to remove.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_detach_tags, \\ref qdb_get_tagged, \\ref qdb_get_tags"]
    pub fn qdb_detach_tag(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        tag: *const ::std::os::raw::c_char,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Removes a collection of tags from a single entry.\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The entry must exist.\n!\n! The tags must exist.\n!\n! Consider using \\ref qdb_detach_tag if you are removing a single tag.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry to which the tags must be removed.\n!\n! \\param tags A pointer to an array of null-terminated UTF-8 strings\n! representing the tags to remove.\n!\n! \\param tag_count The count of tags to remove to the entry.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_detach_tag, \\ref qdb_get_tagged, \\ref qdb_get_tags"]
    pub fn qdb_detach_tags(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        tags: *const *const ::std::os::raw::c_char,
        tag_count: usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Retrieves all entries that have the specified tag\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The tag must exist.\n!\n! The complexity of this function is constant.\n!\n! Consider using \\ref qdb_tag_iterator_begin if you expect the number of\n! entries to be very large.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag for which to search entries.\n!\n! \\param[out] aliases A pointer to an array of null-terminated UTF-8\n! string that will list the aliases of the entries having the requested\n! tag.\n!\n! \\param[out] alias_count A pointer to an integer that will receive the\n! number of returned aliases.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tags, \\ref qdb_tag_iterator_begin, \\ref qdb_release"]
    pub fn qdb_get_tagged(
        handle: qdb_handle_t,
        tag: *const ::std::os::raw::c_char,
        aliases: *mut *mut *const ::std::os::raw::c_char,
        alias_count: *mut usize,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Computes the count of all entries matching the\n! specified tag, up to the configured max cardinality.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag for which to search entries.\n!\n! \\param[out] count A pointer to an integer that will receive the count of\n! tags\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tags, \\ref qdb_get_tagged, \\ref\n! qdb_option_set_max_cardinality"]
    pub fn qdb_get_tagged_count(
        handle: qdb_handle_t,
        tag: *const ::std::os::raw::c_char,
        count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Computes the approximate count of all entries matching the\n! specified tag, up to the configured max cardinality.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag for which to search entries.\n!\n! \\param[out] count A pointer to an integer that will receive the count of\n! tags\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tags, \\ref qdb_get_tagged, \\ref\n! qdb_option_set_max_cardinality"]
    pub fn qdb_get_tagged_approximate_count(
        handle: qdb_handle_t,
        tag: *const ::std::os::raw::c_char,
        count: *mut qdb_uint_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Retrieves all the tags of an entry\n!\n! Tagging an entry enables you to search for entries based on their tags.\n! Tags scale across nodes.\n!\n! The entry must exist.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param alias A pointer to a null-terminated UTF-8 string representing\n! the alias of the entry to which the tag must be added.\n!\n! \\param[out] tags A pointer to an array of null-terminated UTF-8 string\n! that will list the tags of the entry\n!\n! \\param[out] tag_count A pointer to an integer that will receive the\n! number of returned tags.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tagged, \\ref qdb_release"]
    pub fn qdb_get_tags(
        handle: qdb_handle_t,
        alias: *const ::std::os::raw::c_char,
        tags: *mut *mut *const ::std::os::raw::c_char,
        tag_count: *mut usize,
    ) -> qdb_error_t;
}
#[doc = "! \\ingroup tag\n! \\brief An iterator to iterate on the entries matching a certain tag."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qdb_const_tag_iterator_t {
    #[doc = "! the associated handle\n! set by \\ref qdb_tag_iterator_begin"]
    pub handle: qdb_handle_t,
    #[doc = "! reserved do not use\n! set by \\ref qdb_tag_iterator_begin"]
    pub token: *const ::std::os::raw::c_void,
    #[doc = "! reserved do not use\n! set by \\ref qdb_tag_iterator_begin"]
    pub magic: qdb_size_t,
    #[doc = "! The alias of the current entry"]
    pub alias: *const ::std::os::raw::c_char,
    #[doc = "! The type of the current entry"]
    pub type_: qdb_entry_type_t,
}
#[test]
fn bindgen_test_layout_qdb_const_tag_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<qdb_const_tag_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<qdb_const_tag_iterator_t>(),
        40usize,
        concat!("Size of: ", stringify!(qdb_const_tag_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<qdb_const_tag_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(qdb_const_tag_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_tag_iterator_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_tag_iterator_t),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_tag_iterator_t),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_tag_iterator_t),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qdb_const_tag_iterator_t),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Creates an iterator that will point to the first entry having the\n!        the specified tag.\n!\n! The order in which iteration occurs is unspecified, but entries matching\n! a tag will never appear twice.\n!\n! Only forward iteration is currently supported.\n!\n! Once iteration terminates, the caller is responsible for releasing\n! API-allocated resources with \\ref qdb_tag_iterator_close\n!\n! If you expect the number of entries to be very small, you might consider\n! using \\ref qdb_get_tagged.\n!\n! \\param handle A valid handle previously initialized by \\ref qdb_open or\n! \\ref qdb_open_tcp.\n!\n! \\param tag A pointer to a null-terminated UTF-8 string representing the\n! tag on which iteration is requested\n!\n! \\param[out] iterator A pointer to an uninitialized \\ref\n! qdb_const_tag_iterator_t\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tagged, \\ref qdb_tag_iterator_next, \\ref\n! qdb_tag_iterator_close"]
    pub fn qdb_tag_iterator_begin(
        handle: qdb_handle_t,
        tag: *const ::std::os::raw::c_char,
        iterator: *mut qdb_const_tag_iterator_t,
    ) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Advance a previously initialized iterator to the next entry.\n!\n! The order in which iteration occurs is unspecified, but entries matching\n! a tag will never appear twice.\n!\n! Only forward iteration is currently supported.\n!\n! Once iteration terminates, the caller is responsible for releasing\n! API-allocated resources with \\ref qdb_tag_iterator_close\n!\n! If you expect the number of entries to be very small, you might consider\n! using \\ref qdb_get_tagged.\n!\n! \\param[in,out] iterator A pointer to an initialized \\ref\n! qdb_const_tag_iterator_t\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_get_tagged, \\ref qdb_tag_iterator_begin, \\ref\n! qdb_tag_iterator_close"]
    pub fn qdb_tag_iterator_next(iterator: *mut qdb_const_tag_iterator_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup tag\n! \\brief Releases all API-allocated resources during a previous iteration.\n!\n! Once iteration terminates, the caller is responsible for releasing\n! API-allocated resources with \\ref qdb_tag_iterator_close\n!\n! \\param[in,out] iterator A pointer to an initialized \\ref\n! qdb_const_tag_iterator_t\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_tag_iterator_begin"]
    pub fn qdb_tag_iterator_close(iterator: *mut qdb_const_tag_iterator_t) -> qdb_error_t;
}
extern "C" {
    #[doc = "! \\ingroup client\n! \\brief Clones a previously initialized tag iterator.\n!\n! Copies the state of the original iterator to a new iterator. Both\n! iterators can be independently operated afterwards. The cloned iterator\n! will have to be closed with \\ref qdb_tag_iterator_close.\n!\n! \\param original The original iterator to copy, source.\n!\n! \\param[out] copy An uninitialized iterator to be set, destination.\n!\n! \\return A \\ref qdb_error_t code indicating success or failure.\n!\n! \\see \\ref qdb_tag_iterator_begin, \\ref qdb_tag_iterator_close"]
    pub fn qdb_tag_iterator_copy(
        original: *const qdb_const_tag_iterator_t,
        copy: *mut qdb_const_tag_iterator_t,
    ) -> qdb_error_t;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
